;
; Global Variables:
;
;   $300    Start of the program area, extends to $37F.
;   $380    Start of the storage area for Vnn registers, extends to $3BF.
;   $4E6    Decimal, octal, or hexadecimal number format.
;   $4E7    Currently selected input and output devices.
;   $4E8    Current command character, aligned in bits 32..39.
;   $4EA    Saved A value to pass to native code executed with "J".
;   $4EB    Saved K value to pass to native code executed with "J".
;   $4ED    Mode: 1 = program registers, -1 = storage registers, 0 = hex mode.
;   $4F1    Link address for subroutines.
;   $4F2    Link address for subroutines.
;   $4F4    Register number that was entered by the user.
;   $4F9    Link address for low-level subroutines.
;   $4FB    Return instruction for the high-level interpreter, used by JR & JMK.
;   $4FC    Return address for the high-level interpreter, used by JR & JMK.
;   $4FD    Contents of a register when fetching from memory.
;   $4FE    Link address for low-level subroutines.
;   $4FF    Character input routine that waits for input and then jumps to $50E.
;
; The block interchange contains the high-level language's state:
;
;   BI-1    A register
;   BI-2    Current instruction word being executed, 10 bits per instruction
;   BI-5    B register
;   BI-6    Address of the current instruction word being executed
;

;
; $FFF - Main entry point to OPUS upon a HALT, READY, RUN sequence.
; $7FF - Enter OPUS from a user program.
;
FFF: 00 E7 FF 10 08           JU    $7FF
7FF: 74 B4 EA 09 08           ST    $4EA        ; Save the startup A in $4EA.
                              CL   
                              AK   
774: 7B B4 EB 0F 0A           ST    $4EB        ; Save the startup K in $4EB.
                              BI                ; Block interchange.
77B: 87 7E C0 7E 49           IS    $C0         ; Reset all I/O devices.
                              IS    $49         ; Select keyboard and printer.
787: 6C 87 10 B4 E7           CA    $710        ; Load $49 into A
                              ST    $4E7        ; and store it to $4E7.
76C: 88 87 F0 B4 FF           CA    $7F0        ; Set $4F0 to a character
                              ST    $4FF        ; input routine.
788: 14 C7 8A 09 10           JM    $78A        ; Print a CRLF.
                              CL   
                              SK   
714: 72 08 B4 ED 0A           AK                ; Store A = 1 to $4ED
                              ST    $4ED        ; (select program registers).
772: 00 87 F6 E7 7A           CA    $7F6        ; Set the number format in
77A: 00 B4 E6 E7 6A           ST    $4E6        ; $4E6 to "octal".
;
; Main input loop.
;
76A: 1D 7E 41 48 A7           IS    $41         ; Select the printer.
                              BRSK  40          ; Set A to all 1 bits.
71D: 29 40 01 F7 1D           BLS   2           ; Delay loop, 20 iterations.
                              JC    $71D
729: DC 7E 49 48 A7           IS    $49         ; Select keyboard and printer.
                              BRSK  40          ; Set A to all 1 bits.
7DC: 68 40 01 F7 DC           BLS   2           ; Delay loop, 20 iterations.
                              JC    $7DC
768: 6A 5C 00 F5 F0           CIOP              ; Input, odd parity.
                              JC    $5F0
                              JU    $76A        ; No input yet, loop again.
;
; Echo and dispatch the command that was typed from the main input loop.
;
5F0: 7B 12 F7 0C 0A           TH                ; Was there a parity error?
                              JC    $70C        ; Yes, jump tp $70C.
57B: 1E 40 17 B0 02           BLS   24          ; Shift char from bits 0..7 to
                              ST    2           ; bits 24..31 and store in S2.
51E: ED 40 07 B4 E8           BLS   8           ; Shift char to bits 32..39
                              ST    $4E8        ; and store into $4E8.
5ED: ED 70 00 F5 75           OAO               ; Echo the character.
                              JC    $575
                              JU    $5ED        ; Loop until output not busy.
710: 00 00 00 00 49           DW    $0000000049
7F0: 0A 5C 00 F5 0E           DW    $0A5C00F50E
;
; Dispatch the command based on the character in bits 24..31 S2.
; The code here is a little weird, but the overall effect is to do this:
;
;       if (ch >= 0100) {
;           // Character is out of range, no valid handler.
;           goto $76A;
;       }
;       S2 = memory[$600 + ch]
;       goto $790
;
; Effectively, load the handler for the command character (0 to 077) into
; S2 and jump to $790.  Characters 0100 and above are ignored as they only
; move the print head and don't do anything useful.
;
575: 96 48 89 1A 22           BRSK  10          ; Set A to $FFC0000000.
                              LA    2           ; AND A with S2 (char << 24).
                              XC    2
596: 00 F5 9A E7 6A           JC    $59A        ; Skip if A AND S2 was zero.
                              JU    $76A        ; Invalid command character.
59A: 00 95 9E 0D 00           AD    $59E        ; Look up the command handler
                              JA                ; table and jump to $790.
70C: 37 86 AA B0 00           CA    $6AA        ; Load the "ERR" message.
                              ST    0           ; Store to S0 and $4ED.
737: F5 B4 ED 7E 41           ST    $4ED
                              IS    $41         ; Select the printer.
7F5: 00 C6 D4 E7 7B           JM    $6D4        ; Print "ERR".
                              JU    $77B        ; Error printed, go back.
6AA: 00 00 35 29 29 "  ERR"   DW    $0000352929
;
; $59E encodes the instruction sequence CA $600 / XC 2 / JU $790 which
; performs a memory pointer lookup on $600 + ch.
;
59E: 86 00 22 E7 90           DW    $860022E790
;
; Dispatch the command word in S2.  If bit 0 is zero or bit 3 is 1,
; then the command character was unrecognised.  Jump back to the main
; input loop at $76A for unrecognised commands.
;
790: 9F 87 11 2A 0A           CA    $711
                              XT    2
79F: 2A 48 00 F7 27           BRS   1
                              JC    $727
72A: 00 E7 6A 00 00           JU    $76A
727: 35 48 02 F7 6A           BRS   3
                              JC    $76A
735: 00 97 B9 0D 00           AD    $7B9
                              JA
7B9: 0A 78 41 F6 80           DW    $0A7841F680
70A: 00 97 13 0D 00           AD    $713
                              JA
711: 00 00 00 03 FF           DW    $00000003FF
713: 7E 00 E0 00 00           DW    $7E00E00000
;
; $600 - Character information table.  Different bits of this table
; provide information about characters for the command loop, number
; parsing, number formatting, etc.
;
; Each word in this table provides information about the characters
; 000 to 077 (octal).  This table is used to help dispatch commands.
;
;   Bit     Meaning
;   0       1 for command character, 0 for parsed digit value
;   1       ???
;   2       1 for a terminating character like space, CR, P1, II, etc.
;   3       0 if the character is valid as a command, 1 if valid as a digit.
;   4-9     N, address of the command handler ($680 + N) if bit 0 is 1.
            N, the parsed digit value if bit 0 is 0.
;   10-31   ???
;   32-39   Odd words map digits 0-9,A-F to their character code form.
;
; The high byte in words $601, $603, $605, etc provide the character codes
; for digits 0-9,A-F for use in number formatting.
;
600: 4B 58 C0 01 04     ; Space
601: 10 10 06 00 18     ; 1
602: E6 50 00 00 28     ; 2
603: 01 50 00 80 3A     ; 3
604: 99 44 C0 00 48     ; 4
605: 02 42 01 80 58     ; 5
606: D1 49 C0 00 68     ; 6
607: 03 64 07 00 78     ; 7
608: 4F 1C 80 00 8A     ; 8
609: 04 64 09 00 9A     ; 9
60A: 85 99 C0 00 00     ; @ / CLEAR
60B: 05 48 0C 00 14     ; # / P0
60C: 86 48 80 00 F1     ; P1 - Read Program Tape         - Handler: $68F
60D: 06 48 0A 00 41     ; P2 - Verify Program Tape       - Handler: $684
60E: 85 49 C0 00 00     ; P3
60F: 07 48 0E 00 00     ; P4
610: 86 74 80 00 08     ; 0
611: 08 80 00 10 44     ; /
612: 49 50 00 00 B1     ; S - Store Instructions or Data - Handler: $68B
613: 09 44 04 00 71     ; T - Punch Program onto Tape    - Handler: $687
614: C9 50 00 00 01     ; U - ??? - Same as P            - Handler: $680
615: 31 44 03 00 A1     ; V - Select Storage Registers   - Handler: $68A
616: C7 3C C0 00 C1     ; W - Print Registers            - Handler: $68C
617: 32 44 02 00 D1     ; X - Print Register A           - Handler: $68D
618: 51 50 00 00 E1     ; Y - Print Register B           - Handler: $68E
619: 33 44 05 00 01     ; Z - Same as P                  - Handler: $680
61A: 93 45 40 00 00     ; *
61B: 34 42 01 00 24     ; ,
61C: 5F 3C 80 00 24     ; I
61D: 35 80 00 04 44     ; II
61E: 5F 35 40 00 00     ; III
61F: 36 80 00 15 01     ; IIII - Run Application         - Handler: $690
620: CE 3A 40 00 02     ; - / Diamond
621: 00 80 00 20 11     ; J - Jump to Native Code        - Handler: $681
622: C7 4D 00 00 21     ; K - Print Native Accumulator   - Handler: $682
223: 00 80 00 08 31     ; L - Punch Tape Leader          - Handler: $683
624: 97 7C 40 00 01     ; M - Same as P                  - Handler: $680
625: 00 80 00 24 51     ; N - Select Decimal Format      - Handler: $685
626: 97 7C 80 00 61     ; O - Select Octal Format        - Handler: $686
627: 00 80 00 28 01     ; P - Select Program Registers   - Handler: $680
628: 86 90 00 00 81     ; Q - Change Register            - Handler: $688
629: 00 80 00 0C 91     ; R - Reset Memory               - Handler: $689
62A: 4A 2E 67 00 00     ; %
62B: 00 80 00 40 00     ; $
62C: CE 60 00 01 04     ; Index Left + Right
62D: 00 14 08 01 04     ; Index Right
62E: 4B 3E 40 00 00     ; Black Ribbon Print
62F: 00 80 00 38 00     ; Formup
630: 4B 39 80 00 00     ; &
631: 00 80 00 18 A9     ; A
632: E6 5C 40 00 B9     ; B
633: 00 80 00 2C C9     ; C
634: C6 10 00 00 D9     ; D
635: 00 80 00 1C E9     ; E
636: D1 3D 65 00 F9     ; F
637: 00 80 00 30 01     ; G - Same as P                  - Handler: $680
638: 49 2C F1 95 11     ; H - Select Hexadecimal Format  - Handler: $691
639: 00 80 00 34 01     ; I - Same as P                  - Handler: $680
63A: 9A 75 12 00 84     ;
63B: 00 80 00 3C 00     ; .
63C: CF 18 F3 00 00     ; Red Ribbon Print
63D: 00 80 00 45 04     ; Index Left
63E: D3 94 93 00 00     ; Backspace
63F: 00 80 00 4C 00     ; Carriage Open or Close
640: D3 38 E9 00 84     ; Carriage Return
;
;
; $534 and $5BC - Control returns to one of these addresses when a command
; handler finishes processing.  Print a CRLF and jump back to the main loop.
;
534: 00 7E 49 E5 BC           IS    $49         ; Select keyboard and printer.
5BC: 00 C7 8A E7 6A           JM    $78A        ; Print a CRLF.
                              JU    $76A        ; Jump back to the main loop.
;
; $680 - Command handler for P, U, Z, G, I, M.
;
; P is "Select Program Registers".  Not sure what the other ones are for.
;
680: 00 87 8C E7 38           CA    $78C        ; Set $4ED to 1
738: 00 B4 ED E5 34           ST    $4ED        ; (select progream registers).
                              JU    $534
78C: 00 00 00 00 01           DW    $0000000001
;
; $681 - Command handler for J - Jump to Native Code (undocumented).
;
681: 00 84 ED E5 21           CA    $4ED        ; Are we in hexadecimal mode?
521: AC 11 F5 A8 0A           TZ   
                              JC    $5A8        ; Jump to $5A8 if we are.
5AC: 00 E7 0C 00 00           JU    $70C        ; Otherwise "ERR" and stop.
5A8: 98 C5 76 C7 8A           JM    $576        ; Prompt for a hex address.
                              JM    $78A        ; Print a CRLF.
598: 00 84 F4 E6 78           CA    $4F4        ; Get the user's address.
678: 00 96 FD E7 81           AD    $6FD        ; Add to instruction at $6FD.
781: 91 B4 FE C7 89           ST    $4FE        ; Put it in $4FE.
                              JM    $789        ; Select the current I/O devs.
791: F1 0F 84 EB 0A           BI                ; Swap in the BI registers.
                              CA    $4EB        ; Load the saved carry flag
7F1: 00 48 00 E4 FE           BRS   1           ; and shift it back into K.
                              JU    $4FE        ; Jump to the native code.
6FD: 00 84 EA E0 00           CA    $4EA
                              JU    $000
;
; $682 - Command handler for K - Print Native Accumulator (undocumented).
;
682: 00 84 ED E5 25           CA    $4ED        ; Are we in hexadecimal mode?
525: AC 11 F7 2C 0A           TZ   
                              JC    $72C        ; Jump to $72C if we are.
                              JU    $5AC        ; Otherwise "ERR" and stop.
72C: 16 84 EA B4 FD           CA    $4EA        ; Copy saved accumulator in
                              ST    $4FD        ; $4EA to $4FD.
716: F9 84 EB B4 F4           CA    $4EB        ; Load the saved K value and
                              ST    $4F4        ; put it into $4F4.
7F9: 26 C6 99 C6 A1           JM    $699        ; Print register number in $4F4.
                              JM    $6A1        ; Print value in $4FD.
726: 00 E5 BC 00 00           JU    $5BC        ; Return to the main loop.
;
; $683 - Command handler for L - Punch Tape Leader.
;
683: 00 87 B8 E5 1C           CA    $7B8
51C: 00 F5 11 E4 F9           JC    $511
                              JU    $4F9        ; Return from subroutine.
511: 22 21 12 F5 9F           XC    1           ; Get the value of S1.
                              TH   
                              JC    $59F
522: 00 0B E5 9F 00           CM   
59F: 00 21 E4 F9 00           XC    1           ; Set S1 to abs(S1).
                              JU    $4F9        ; Return from subroutine.
7B8: FF FF FF FF D8           DW    $FFFFFFFFD8
;
; $684 - Command handler for P2 - Verify Program Tape.
;
; TODO
;
684: 00 85 1D E5 29           CA    $51D
                              JU    $529
;
; $685 - Command handler for N - Select Decimal Format.
;
685: 00 87 42 E7 C6           CA    $742
7C6: 00 B4 E6 E5 34           ST    $4E6
                              JU    $534
;
; $742 - Edit word for formatting numbers in decimal.
;
; $C9148A4520 is 14442442442440 in octal which indicates:
;
;       1       Show the sign before the number
;       444     Decimal digits with leading zero suppression
;       244     Comma, then decimal digits with leading zero suppression
;       0       Trailing space
;
742: C9 14 8A 45 20           DW    $C9148A4520
;
; $686 - Command handler for O - Select Octal Format.
;
; $67B3D9ECF6 is 06366366366366 in octal which indicates:
;
;       0       No leading sign
;       6       Single octal digit
;       366     Comma and then three octal digits
;
686: 00 87 F6 E7 C6           CA    $7F6
                              JU    $7C6
7F6: 67 B3 D9 EC F6           DW    $67B3D9ECF6 ; Edit word for octal.
;
; $687 - Command handler for T - Punch Program onto Tape.
;
; TODO
;
687: 00 84 ED E5 23           CA    $4ED
                              JU    $523
;
; $688 - Command handler for Q - Change Register.
;
; TODO
;
688: 00 C5 76 E5 3F           JM    $576        ; Prompt for register number.
53F: B2 C5 35 C7 2E           JM    $535        ; Move print head to column 19.
                              JM    $72E        ; Read memory at $4F4 into $4FD.
5B2: C2 C5 3B F2 C3           JM    $53B        ; Are we in program reg mode?
                              JC    $2C3        ; Yes, jump to $2C3.
5C2: BD C6 A1 C5 37           JM    $6A1        ; Print the value in $4FD.
                              JM    $537        ; Move print head to column 46.
5BD: 00 C6 BF E5 3F           JM    $6BF        ; Read number into storage reg.
                              JU    $53F        ; Go back for next word.
2C3: 00 C2 2A E2 2E           JM    $22A
22E: A9 C4 0A 84 F8           JM    $40A
                              CA    $4F8
2A9: 31 B0 00 C2 2D           ST    0
                              JM    $22D
231: C5 C5 38 C4 BC           JM    $538
                              JM    $4BC
2C5: 00 F5 3F E2 2E           JC    $53F
                              JU    $22E
;
; $689 - Command handler for R - Reset Memory.
;
; Starts by printing "4DEB" to the console and then waits for the user to
; press a key.  Note: The programming manual states that this should print
; "RESET" rather than "4DEB".  Not sure why the discrepancy.
;
; If the user presses "SHIFT+P4", then the program and storage registers will
; be cleared.  Otherwise OPUS prints "ERR" and goes back to the main loop.
;
689: 00 C2 DA E5 34           JM    $2DA
                              JU    $534
2DA: 6F 24 84 48 20           XC    4           ; Shift return address into S4.
                              CA    $448        ; Print "4DEB", move to col 28.
                              XC    0
26F: 00 C6 D4 E4 58           JM    $6D4        ; Call print message routine.
458: 58 5C 00 F7 E0           CIOP              ; Wait for input.
                              JC    $7E0
                              JU    $458
7E0: EF 96 E4 11 0A           AD    $6E4        ; Was the key SHIFT+P4?
                              TZ   
7EF: 00 F6 B3 E7 0C           JC    $6B3
                              JU    $70C        ; No, print "ERR" and stop.
6B3: CF 87 C2 B0 01           CA    $7C2        ; Build a program in
                              ST    1           ; A, S0, S1, S2, S3 to
6CF: DE 87 D4 B0 02           CA    $7D4        ; reset the registers.
                              ST    2
6DE: 6F 86 62 B0 03           CA    $662
                              ST    3
66F: D0 87 73 B0 00           CA    $773
                              ST    0
6D0: 00 95 D7 E0 03           AD    $5D7
                              JU    3           ; Jump to the program we built.
448: 04 34 35 32 49 "4DEB."   DW    $0434353249
6E4: FF FF FF FF B1           DW    $FFFFFFFFB1 ; Negated SHIFT+P4 char code.
;
; The following words are loaded into A, S0, S1, S2, and S3 to create a
; loop that resets all program and storage registers, modifying the address
; each time through the loop.  Effectively the code is as follows:
;
;       S0 = $000707E3C0
;       A  = $000707E2FF
;   3:  SK                  ; Increment A.
;       AK
;       TE 0                ; Have we reached the end of the registers?
;   1:  JC 4                ; Return from subroutine at the end.
;       ST $300+N           ; Store the pattern in A to address $300+N.
;   2:  XC 1                ; Exchange A and S1.
;       SK                  ; Increment the instruction at address "1:".
;       AK
;       XC 1                ; Put the modified instruction back at address "1:".
;       JU 3                ; Back around for the next word.
;
5D7: FF FF FF FF 3F           DW    $FFFFFFFF3F
662: 01 10 08 30 0A           DW    $011008300A
773: 00 07 07 E3 C0           DW    $000707E3C0
7C2: 02 F0 04 B3 00           DW    $02F004B300
7D4: 03 21 10 08 21           DW    $0321100821
;
; $68A - Command handler for V - Select Storage Registers.
;
68A: 00 87 78 E7 38           CA    $778        ; Set $4ED to -1
                              JU    $738        ; (select storage registers).
778: FF FF FF FF FF           DW    $FFFFFFFFFF
;
; $68B - Command handler for S - Store Instructions or Data.
;
68B: 00 C5 76 E2 46           JM    $576        ; Prompt for the address.
246: 48 C5 35 C5 3B           JM    $535        ; Move print head to column 19.
                              JM    $53B        ; Are we in program reg mode?
248: 46 F2 CC C6 BF           JC    $2CC        ; Yes, jump to $2CC.
                              JM    $6BF        ; Read number into storage reg.
                              JU    $246        ; Go back for the next word.
2CC: AA 85 8C B4 F5           CA    $58C
                              ST    $4F5        ; Store 7 to $4F5..$4F8.
2AA: AD B4 F6 B4 F7           ST    $4F6
                              ST    $4F7
2AD: 00 B4 F8 E3 FE           ST    $4F8
3FE: FE C4 BC F2 46           JM    $4BC
                              JC    $246
                              JU    $3FE
58C: 00 00 00 00 07           DW    $0000000007
;
; $68C - Command handler for W - Print Registers in a range.
;
68C: 00 C5 76 E5 41           JM    $576        ; Prompt for first register.
541: B3 C5 0F C7 8A           JM    $50F        ; Prompt for last register.
                              JM    $78A        ; Print CRLF.
5B3: BA C6 99 C5 35           JM    $699        ; Print the register number.
                              JM    $535        ; Move print head to column 19.
5BA: C0 C7 2E C5 3B           JM    $72E        ; Read memory at $4F4 into $4FD.
                              JM    $53B        ; Are we in program reg mode?
5C0: B8 F2 C7 C6 A1           JC    $2C7        ; Yes, jump to $2C7.
                              JM    $6A1        ; Print the value in $4FD.
5B8: B4 C7 8A C7 95           JM    $78A        ; Print CRLF.
                              JM    $795        ; Check for the end of all regs.
5B4: 00 F5 BC E5 B3           JC    $5BC        ; Jump to $5BC if we are done.
                              JU    $5B3        ; Go back for the next register.
2C7: 00 C2 2A E4 AF           JM    $22A
4AF: A8 C4 0A 84 F8           JM    $40A
                              CA    $4F8
4A8: B5 11 F4 B1 0A           TZ   
                              JC    $4B1
4B5: B2 B0 00 C2 2D           ST    0
                              JM    $22D
4B2: C5 24 11 F4 C2           XC    4
                              TZ   
                              JC    $4C2
4C5: 2A 94 61 24 0A           AD    $461
                              XC    4
42A: 00 C5 36 E4 AF           JM    $536
                              JU    $4AF
4B1: DD 84 54 B0 00           CA    $454
                              ST    0
                              JU    $4DD
4C2: 00 C7 8A E5 B8           JM    $78A        ; Print a CRLF.
5B8: B4 C7 8A C7 95           JM    $78A        ; Print another CRLF.
                              JM    $795
5B4: 00 F5 BC E5 B3           JC    $5BC
                              JU    $5B3        ; Go back for the next register.
;
; $53B - Copies $676 to S4 and sets K to 1 if program register mode is active.
;
53B: AF B4 F2 86 76 ".D.6."   ST    $4F2        ; Put return address in $4F2.
                              CA    $676
5AF: B1 24 84 ED 0B "AM4.#"   XC    4           ; Put contents of $676 in S4.
                              CA    $4ED        ; Get the register mode.
                              CM                ; Negate the mode.
5B1: 00 08 E4 F2 00 " 8.. "   AK                ; Add 1 if mode was non-zero.
                              JU    $4F2        ; K is set now if $4ED was 1.
676: FF FF FD 00 00           DW    $FFFFFD0000
;
; $68D - Command handler for X - Print Register A.
;
68D: B0 0F 80 01 0F           BI   
                              CA    1           ; Fetch A from BI register 1.
                              BI   
6B0: CE 20 87 42 21           XC    0
                              CA    $742
                              XC    1
6CE: 00 C7 00 E5 BC           JM    $700
                              JU    $5BC
;
; $68E - Command handler for Y - Print Register B.
;
68E: B0 0F 80 05 0F           BI   
                              CA    5           ; Fetch B from BI register 5.
                              BI   
                              JU    $6B0
;
; $68F - Command handler for P1 - Read Program Tape.
;
; TODO
;
68F: 00 84 ED E5 0D           CA    $4ED
                              JU    $50D
;
; $452 - Instructions in the high-level language for initializing the
; interpreter and jumping into the user's code to get the ball rolling:
;
;       000     Skipped by "BLS 10" at $40E below
;       189     Select keyboard and printer devices for I/O
;       240     Move the tab position to column 1
;       380     Jump unconditional to program register $000
;
452: 00 18 99 03 80           DW    $0018990380
;
; $690 - Command handler for IIII - Run Application.
;
690: 00 E4 C1 00 00           JU    $4C1
4C1: 80 0F 84 52 22           BI            ; Swap in BI as the active regs.
                              CA    $452    ; Load the initialization word
                              XC    2       ; into BI-2 to get things rolling.
;
; $480 - Interpreter main execution loop.
;
; BI-2 contains the current instruction that is being executed.
; Each instruction is 10 bits in length with 4 instructions per word.
;
; Start by shifting the current instruction word in BI-2 left by 10 bits to
; remove the last instruction that we just executed.
;
480: 0E 84 84 2A 0A           CA    $484    ; Separate the top 10 bits and
                              XT    2       ; bottom 30 bits of BI-2.
40E: 29 B0 00 40 09           ST    0       ; Put the bottom 30 bits in BI-0.
                              BLS   10      ; Shift out the last instruction.
429: C0 11 22 F3 D7           TZ            ; Is the remainder of the word 0?
                              XC    2       ; Put rest of the word into BI-2.
                              JC    $3D7    ; If zero, goto $3D7.
;
; We now have the next instruction to be executed in the top 10 bits of BI-2.
; Inspect the bit pattern to figure out how to handle the instruction:
;
;   00 00xx xxxx    Handled by $4D2
;   00 01xx xxxx    Handled by $465
;   0n nnyy yyyy    Handled by $3C0+0nnn    (variable register instructions)
;   1n nyyy yyyy    Handled by $3C0+1nn0    (program register instructions)
;
4C0: 4E 84 44 3A 0A           CA    $444
                              TG    2
44E: 59 F4 D2 40 00           JC    $4D2    ; Goto $4D2 if 00 00xx xxxx.
                              BLS   1
459: 69 3A F4 65 0A           TG    2
                              JC    $465    ; Goto $465 if 00 01xx xxxx.
;
; $469 - Determine if the instruction is 0n nnyy yyyy or 1n nyyy yyyy.
;
469: 7A 80 02 12 0A           CA    2       ; Check the high bit of the
                              TH            ; current instruction.
47A: 07 84 7E D4 83           CA    $47E    ; A = $0003F00000 or $0007F00000
                              AC    $483    ; based on high bit of 0 or 1.
407: A3 28 48 03 20           XT    0       ; Extract nn and yy parts of the
                              BRS   4       ; instruction, with yy in BI-0 and
                              XC    0       ; the nn part in A.
4A3: 30 48 01 94 2C           BRS   2
                              AD    $42C
430: 00 0D 00 00 00           JA            ; Jump to $3C0+nn.
;
; $465 - Handle instructions with the bit pattern 00 01xx xxxx.
;
465: 76 85 69 1A 0A           CA    $569    ; Extract the bottom 5 bits of
                              LA    2       ; the instruction into A.
;
; The next two instructions format a sequence of instructions in A:
;
;   83 80 + xxxxx   CA $380+xxxxx           ; Load variable register xxxxx.
;   20              XC 0                    ; Put it into BI-0.
;   E4 0B           JU $40B                 ; Jump to $40B.
;
476: 30 48 05 92 84           BRS   6
                              AD    $284
                              JU    $430    ; Execute the instruction in A.
569: 07 C0 00 00 00           DW    $07C0000000
284: 83 80 20 E4 0B           DW    $838020E40B
;
; $4D2- Handle instructions with the bit pattern 00 00xx xxxx.
;
;   00 000x xxxx    Handled by $3D0+0xxxxx
;   00 001x 0000    Handled by $3D0+1x0000
;   00 001x yyyy    Handled by $405 if yyyy is non-zero
;
4D2: 5E 48 00 3A 0A           BRS   1       ; Check for 00 000x xxxx or
                              TG    2       ; 00 001x xxxx.
45E: 70 F4 62 84 74           JC    $462
                              CA    $474    ; 00 001x xxxx case.
470: 05 1A F4 62 0A           LA    2       ; Check for 00 001x 0000.
                              JC    $462    ; If yes, use $462 to handle it.
                              JU    $405    ; Otherwise use $405.
462: 78 80 02 48 05           CA    2       ; 00 00nx xxxx case.
                              BRS   6
478: 00 94 7C 0D 00           AD    $47C    ; Dispatch nxxxxx to $3D0+nxxxxx.
                              JA
405: 11 94 09 0B 0A           AD    $409
                              CM   
411: 24 B0 00 27 21           ST    0
                              XC    7
                              XC    1
424: 80 25 C4 28 0A           XC    5
                              JM    $428        ; TODO
                              JU    $480
;
409: 00 40 00 00 00           DW    $0040000000
42C: E3 C0 00 00 00           DW    $E3C0000000
444: 0F FF FF FF FF           DW    $0FFFFFFFFF
474: 03 C0 00 00 00           DW    $03C0000000
47E: 00 03 F0 00 00           DW    $0003F00000
47C: E3 D0 00 00 00           DW    $E3D0000000
483: 00 04 00 00 00           DW    $0004000000
484: 00 3F FF FF FF           DW    $003FFFFFFF
;
; $691 - Command handler for H - Select Hexadecimal Format.
;
691: EA 86 71 B4 E6           CA    $671        ; Select hexadecimal mode.
                              ST    $4E6
6EA: F4 09 B4 ED 0A           CL   
                              ST    $4ED        ; Set the mode in $4ED to 0.
6F4: 00 E5 BC 00 00           JU    $5BC
671: 7E 49 20 00 00           DW    $7E49200000 ; Edit word for hexadecimal.
;
; $576 - Subroutine that waits for the first register number in a range
; to be entered and returns it in $4F4.
;
576: 15 B4 F1 C5 0F           ST    $4F1        ; Save return address in $4F1.
                              JM    $50F        ; Read in a number.
515: 00 B4 F4 E4 F1           ST    $4F4        ; Store the number in $4F4.
                              JU    $4F1        ; Return to the caller.
;
; $50F - Subroutine that waits for a register number to be entered.
;
; The number is returned in A.
;
50F: F1 B4 FE 84 ED           ST    $4FE        ; Save return address in $4FE.
                              CA    $4ED        ; What mode are we in?
5F1: 7E 11 F5 78 12           TZ                ; 0 means hexadecimal mode.
                              JC    $578        ; 1 means program registers.
                              TH                ; -1 means storage registers.
57E: 8A 85 82 D7 86           CA    $582        ; Compute the register limit.
                              AC    $786
58A: 88 B0 03 C5 83           ST    3           ; Set S3 to the register limit.
                              JM    $583        ; Read decimal number.
588: 00 F5 8E E7 0C           JC    $58E
                              JU    $70C        ; Print "ERR" and stop.
578: 8F 86 7C B0 03           CA    $67C        ; Hexadecimal address mode,
                              ST    3           ; change the limit to $FFF.
58F: 00 C5 85 E5 88           JM    $585        ; Read hexadecimal number.
                              JU    $588
58E: 1A 3B F7 0C 0A           TG    3           ; Number over the limit?
                              JC    $70C        ; Print "ERR" and stop.
51A: 00 E4 FE 00 00           JU    $4FE        ; Return to the caller.
582: 00 00 00 03 80           DW    $0000000380
67C: 00 00 00 0F FF           DW    $0000000FFF
786: 00 00 00 00 40           DW    $0000000040
;
; $583 - Read decimal number.
;
583: 14 21 87 8C 22           XC    1           ; Put return address in S1.
                              CA    $78C
                              XC    2           ; Set S2 to 1.
514: 40 C5 17 60 00           JM    $517        ; Read and parse a digit.
                              DLS   1
540: 55 90 05 25 22           AD    5
                              XC    5
                              XC    2
555: 6D 18 27 F5 6A           LA    0
                              XC    7
                              JC    $56A
56D: 00 E7 0C 00 00           JU    $70C
56A: 00 08 E5 71 00           AK   
                              JU    $571
;
; $584 - Read octal number.
;
584: 93 21 85 8C 20           XC    1           ; Put return address in S1.
                              CA    $58C        ; Set S0 to 7.
                              XC    0
593: 40 C5 17 40 02           JM    $517        ; Read and parse a digit.
                              BLS   3           ; Shift up by 3 bits.
                              JU    $540        ; Add it to the working value.
;
; $585 - Read hexadecimal number.
;
585: 94 21 09 20 0A "UJ9-@"   XC    1           ; Put return address in S1.
                              CL                ; Set S0 to zero.
                              XC    0
594: 40 C5 17 40 03 "..X.3"   JM    $517        ; Read and parse a digit.
                              BLS   4           ; Shift up by 4 bits.
                              JU    $540        ; Add it to the working value.
;
; $517 - Read a digit from the currently selected input device into S5.
;
517: 71 26 09 B0 05           XC    6           ; Put return address in S6.
                              CL                ; Clear S5 and S7 to zero.
                              ST    5
571: 00 27 84 FF 0D           XC    7
                              CA    $4FF        ; Call the char input routine.
                              JA                ; Control returns to $50E.
50E: 39 B0 02 40 1F           ST    2           ; Store the character to S2.
                              BLS   32          ; Shift up by 32 bits.
539: 46 70 00 80 02           OAO               ; Echo the character.
                              CA    2           ; Reload original char from S2.
546: 00 F5 4A E5 0E           JC    $54A
                              JU    $50E        ; Loop if output device busy.
54A: 56 95 4E 95 52           AD    $54E        ; Check if char code >= $41.
                              AD    $552
556: 00 F5 5A E7 0C           JC    $55A
                              JU    $70C        ; Print "ERR" and stop if it is.
;
; The following code does a lookup on $600+char to fetch the parsing rule
; for the character that was just typed.
;
55A: 7D 40 17 95 79           BLS   24
                              AD    $579
57D: 00 0D 00 00 00           JA                ; Table lookup for character.
78D: 1E 87 11 1A 0A           CA    $711        ; AND the rule with $3FF.
                              LA    2
71E: 2D B0 02 48 03           ST    2
                              BRS   4           ; Is bit 3 in the rule set?
72D: 40 25 F0 06 25           XC    5           ; Put the digit into S5.
                              JC    6           ; Success if bit 3 is set.
                              XC    5           ; Revert S5.
740: 53 80 02 48 01           CA    2           ; Get the rule again.
                              BRS   2           ; Is bit 1 set?
753: DE F7 57 48 00           JC    $757        ; If yes, jump to $757.
                              BRS   1           ; Is bit 2 set?
7DE: 00 F7 62 E7 0C           JC    $762        ; If yes, jump to $762.
                              JU    $70C        ; Print "ERR" and stop.
757: 69 27 40 00 10           XC    7
                              BLS   1
                              SK   
769: 00 48 80 E5 71           BRSK  1
                              JU    $571
762: 6E 48 01 F7 6B           BRS   2
                              JC    $76B
76E: 03 48 03 27 0A           BRS   4
                              XC    7
                              JU    $703
76B: F8 27 12 F7 0C           XC    7
                              TH   
                              JC    $70C        ; Print "ERR" and stop.
703: 8F F5 71 40 00           JC    $571
                              BLS   1
78F: 9E 27 F7 1A 0A           XC    7
                              JC    $71A
79E: 08 25 B4 FD 25           XC    5
                              ST    $4FD
                              XC    5
708: 76 22 B4 EF 13           XC    2
                              ST    $4EF
                              RK   
776: 00 80 07 E0 01           CA    7
                              JU    $001
71A: 9E 25 0B 25 0A           XC    5
                              CM   
                              XC    5
                              JU    $79E
;
54E: FF FF FF FF BF           DW    $FFFFFFFFBF
552: 00 00 00 00 41           DW    $0000000041
579: 86 00 22 E7 8D           DW    $860022E78D
;
; $528 - Print the character in the high byte of $4E8 and then move the
; print head to column 4.
;
528: EF 20 84 E8 0A           XC    0           ; Move return addr to S0.
                              CA    $4E8        ; Load the character to print.
5EF: 00 96 73 E6 75           AD    $673        ; Add "move to column 4".
                              JU    $675        ; Print the characters in A.
673: 00 41 00 00 00           DW    $0041000000 ; $41 = move to column 4.
;
; $6D4 - Subroutine that prints a 5-character message.
;
; On entry to this subroutine, S0 is set to the 5-character message and
; A contains the "return address" for the subroutine.
;
; As each character is output, A is shifted left by 8 positions.
; Eventually A will be all-zeroes and the message print stops.
;
6D4: 75 20 70 00 11           XC    0     ; Swap S0 and return addr in A.
                              OAO         ; Output high byte of A and shift.
                              TZ          ; Is A now zero?
675: D4 F0 00 20 0A           JC    0     ; Yes, return from subroutine.
                              XC    0     ; No, swap S0 and A back.
                              JU    $6D4  ; And go handle the next character.
;
; $535 - Subroutine that moves the print head to column 19.
;
535: 35 78 46 F7 A0           OI    $46     ; Output $46 ="move to column 19".
                              JC    $7A0
                              JU    $535
7A0: 00 40 07 13 0D           BLS   8
                              RK   
                              JA            ; Return from the subroutine.
;
; $537 - Subroutine that moves the print head to column 46.
;
537: 37 78 4F F7 A0           OI    $4F     ; Output $4F = "move to column 46".
                              JC    $7A0
                              JU    $537
;
; $78A - Subroutine that prints CRLF to the selected output device(s).
;
78A: 8A 78 40 F7 98           OI    $40     ; Output CR.
                              JC    $798
                              JU    $78A
798: 98 78 3D F7 A0           OI    $3D     ; Output LF.
                              JC    $7A0
                              JU    $798
;
; The entry points at $3D0, $3D1, $3D2, etc are the opcode handlers
; for the interpreter.  Opcode N is handled by address $3D0+N.
;
; $3D0 - Opcode 000 - Print "EMPTY ERR" and return to the main loop.
;
; Control gets to opcode 000 if the program jumps to an unused address.
;
3D0: F8 84 54 B0 00           CA    $454        ; "EMPTY" message.
                              ST    0
3F8: F9 7E 41 C6 D4           IS    $41
                              JM    $6D4        ; Print "EMPTY".
3F9: 00 E7 0C 00 00           JU    $70C        ; Print "ERR" and exit.
454: 35 24 27 13 18 "EMPTY"   DW    $3524271318
;
; $3D1 - Opcode 001 - XCB - Exchange A and B.
;
3D1: 00 21 25 E3 FF           XC    1           ; Swap A (BI-1) and B (BI-5).
                              XC    5
3FF: 00 B0 01 E4 80           ST    1           ; Store back to A.
                              JU    $480
;
; $3D2 - Opcode 002 - ADD - Add B to A.
;
3D2: FF 80 05 90 01           CA    5           ; Load the value of B.
                              AD    1           ; Add it to A
                              JU    $3FF        ; and then store back to A.
;
; $3D3 - Opcode 003 - JR - Jump Return.
;
3D3: 00 84 FC E2 85           CA    $4FC        ; Get the return address.
285: 86 26 84 FB 22           XC    6           ; Put it into BI-5.
                              CA    $4FB        ; Get the return instruction.
                              XC    2           ; Put it into BI-2.
286: 00 E4 80 00 00           JU    $480        ; Back to interpreter main loop.
;
; $3D4 - Opcode 004 - JPS - Jump if positive.
;
3D4: 00 80 01 E4 5D           CA    1           ; Get the A register's value.
45D: 6F 12 F4 80 0A           TH                ; Is it positive or negative?
                              JC    $480        ; Jump to $480 if negative.
46F: 80 22 40 09 22           XC    2           ; Shift the instruction word
                              BLS   10          ; in BI-2 by 10 bits to skip
                              XC    2           ; the next instruction.
                              JU    $480        ; Back to interpreter main loop.
;
; $3D5 - Opcode 5 - XCV - Exchange A and V00.
;
3D5: 00 83 80 E4 87           CA    $380        ; Get the value of V00.
487: 80 21 B3 80 0A           XC    1           ; Swap it with the A register.
                              ST    $380        ; Store previous A back to V00.
                              JU    $480        ; Back to interpreter main loop.
;
; $3D6 - Opcode 6 - SCO - Single character output with odd parity.
;
3D6: 00 80 01 E4 E5           CA    1
4E5: 00 40 1F E4 6A           BLS   32
46A: 6A 70 00 F4 80           OAO  
                              JC    $480
                              JU    $46A
;
; $3D7 - Opcode 7 - AJ - Automatic Jump.
;
3D7: 00 26 94 61 0D           XC    6           ; Increment the address in BI-6.
                              AD    $461
                              JA                ; Fetch new instruction word.
461: 00 00 01 00 00           DW    $0000010000
;
; $3D8 - Opcode 008 - CLR - Clear A.
;
3D8: 00 09 E3 FF 00           CL   
                              JU    $3FF
;
; $3D9 - Opcode 009 - NGA - Complement A.
;
3D9: 00 21 0B E3 FF           XC    1
                              CM
                              JU    $3FF
;
; $3DA - Opcode 00A - NGB - Complement B.
;
3DA: 00 25 0B E4 6B           XC    5
                              CM   
46B: 00 25 E4 80 00           XC    5
                              JU    $480
;
; $3DB - Opcode 00B - INA - Input from ASCII-coded tape.
;
    ; TODO
;
; $3DC - Opcode 00C - DTEN - Divide A by 10 and put the quotient in A
; and the remainder in B.
;
3DC: 00 80 01 E5 65           CA    1           ; Get the high-level A register.
565: 45 12 F6 6C 0A           TH                ; Is it negative?
                              JC    $66C        ; Yes, jump to $66C.
545: D8 B0 03 68 00           ST    3           ; Save abs(A) in S3.
                              DRS   1           ; Divide low-level A by 10.
5D8: E5 B0 05 60 00           ST    5           ; Store the result in B.
                              DLS   1           ; Multiply low-level A by 10.
5E5: C5 0B 90 03 25           CM                ; Subtract low-level A from S3.
                              AD    3
                              XC    5           ; Put remainder in B
5C5: 59 21 12 F3 D9           XC    1           ; and the quotient in A.
                              TH                ; If the original number was
                              JC    $3D9        ; negative, negate the final A.
559: 00 E4 80 00 00           JU    $480        ; Back to main interpreter loop.
66C: 00 0B E5 45 00           CM                ; Negate the value.
                              JU    $545        ; Jump back.
;
; $3DD - Opcode 00D - SSCAN - ???
;
3DD: 00 83 83 E2 27           CA    $383        ; Load V03 into A.
227: 3F 25 82 30 23           XC    5
                              CA    $230
                              XC    3
23F: 4C 84 C3 B0 00           CA    $4C3
                              ST    0
24C: 91 83 87 92 0B           CA    $387
                              AD    $20B
291: BD F4 6F 92 B9           JC    $46F
                              AD    $2B9
2BD: 53 90 00 B0 07           AD    0
                              ST    7
                              JU    $253
253: E2 3B F4 6F 0A           TG    3
                              JC    $46F
2E2: F6 C0 07 B0 01           JM    7
                              ST    1
2F6: 8B 1D F4 03 20           LA    5
                              JC    $403
                              XC    0
28B: 1C 0B 90 07 0A           CM   
                              AD    7
21C: 96 B3 87 25 10           ST    $387        ; Store to V07.
                              XC    5
                              SK
296: A2 08 F4 80 0A           AK   
                              JC    $480
2A2: 00 E2 F4 00 00           JU    $2F4
403: 16 10 27 08 0A           SK   
                              XC    7
                              AK   
416: 00 B0 07 E2 53           ST    7
                              JU    $253
46F: 80 22 40 09 22           XC    2
                              BLS   10
                              XC    2
                              JU    $480        ; Back to main interpreter loop.
230: 04 B0 04 8F D0           DW    $04B0048FD0
4C3: 04 B0 04 88 00           DW    $04B0048800
;
; $3DE - Opcode 00E - SCI - Single character input.
;
3DE: DE 5C 00 F4 66           CIOP 
                              JC    $466
                              JU    $3DE
466: 71 12 F4 6D 0A           TH   
                              JC    $46D
471: 00 E3 FF 00 00           JU    $3FF
46D: 72 84 E7 48 03           CA    $4E7
                              BRS   4
472: 7B F7 77 04 0A           JC    $777
                              HH    4
47B: 00 E3 DE 00 00           JU    $3DE
777: 00 02 E3 DE 00           HH    2
                              JU    $3DE
;
; $3DF - Opcode 00F - OPUS - Return to OPUS.
;
3DF: 00 E7 FF 00 00           JU    $7FF
;
; $3E0 - Opcode 010 - SKIP - Skip field from tape.
;
3E0: FA 82 23 B0 00           CA    $223
                              ST    0
3FA: FA 5C 00 F4 08           CIOP 
                              JC    $408
                              JU    $3FA
408: 1B 12 F4 0F 30           TH   
                              JC    $40F
                              TE    0
41B: 00 F4 80 E3 FA           JC    $480
                              JU    $3FA
40F: 00 04 E3 FA 00           HH    4
                              JU    $3FA
;
; $3E1 - Opcode 011 - CALC - Calculate.
;
3E1: 00 C6 65 E2 22           JM    $665
                              JU    $222
;
; $3E2 - Opcode 012 - DCLR - Clear Distribution Registers.
;
; This builds a small program in the scratchpad loop to clear the 2000
; distribution registers between $800 and $FCF to all zeroes.
;
;      CL
;   3: ST $DCC
;      ST $BE8
;   4: ST $800
;      ST $A04
;   5: XC 3
;      AD 7
;      XC 3
;   6: XC 4
;      TE 0
;      JC $3F7
;   1: AD 7
;      XC 4
;      CL
;      JU 3
;   0: ST $A03
;      ST $C07
;      JU 5
;   7: DW $0000010001
;
3E2: 00 C6 65 E2 35           JM    $665
235: E7 84 39 B0 00           CA    $439
                              ST    0
2E7: B4 82 6B B0 01           CA    $26B
                              ST    1
2B4: 37 82 EB B0 03           CA    $2EB
                              ST    3
237: B7 82 EE B0 04           CA    $2EE
                              ST    4
2B7: E9 84 BB B0 05           CA    $4BB
                              ST    5
2E9: 6C 82 ED B0 06           CA    $2ED
                              ST    6
26C: EC 82 F0 B0 07           CA    $2F0
                              ST    7
2EC: 00 09 E0 03 00           CL   
                              JU    3
3F7: FB 84 EB 26 0A           CA    $4EB
                              XC    6
3FB: FC 84 FA 22 0A           CA    $4FA
                              XC    2
                              JU    $3FC
;
439: 05 BA 03 BC 07           DW    $05BA03BC07
26B: 03 90 07 24 09           DW    $0390072409
2EB: 04 BD CC BB E8           DW    $04BDCCBBE8
2EE: 05 B8 00 BA 04           DW    $05B800BA04
4BB: 06 23 90 07 23           DW    $0623900723
2ED: 01 24 30 F3 F7           DW    $012430F3F7
2F0: 00 00 01 00 01           DW    $0000010001
;
; $3E3 - Opcode 013 - DIST - Distribute.
;
3E3: 00 C6 65 E2 07           JM    $665
                              JU    $207
;
; $3E4 - Opcode 014 - DGET - Bring the Distribution Register V07 into A.
;
3E4: FC 21 25 C6 70           XC    1           ; Shift registr A into B.
                              XC    5
                              JM    $670        ; Fetch D[V07] into A.
3FC: 00 E4 80 00 00           JU    $480        ; Back to main interpreter loop.
;
; $3E5 - Opcode 015 - DPUT - Store A to the Distribution Register V07.
;
3E5: 00 83 87 E2 03           CA    $387        ; Load the value of V07.
                              JU    $203
;
; $3E6 - Opcode 016 - SCAN - Scan for Non-zero Distribution Register.
;
3E6: 00 87 78 E2 27           CA    $778
                              JU    $227
;
; $3E7 - Opcode 017 - ALFI - Alphanumeric Input.
;
3E7: 00 82 23 E5 E0           CA    $223
5E0: CC 25 86 C5 21           XC    5
                              CA    $6C5
                              XC    1
5CC: CC 5C 00 F5 54           CIOP 
                              JC    $554
                              JU    $5CC
554: E7 35 21 F5 64           TE    5
                              XC    1
                              JC    $564
5E7: C3 40 07 90 01           BLS   8
                              AD    1
5C3: D1 B0 01 12 0A           ST    1
                              TH   
5D1: 00 F5 CC E4 80           JC    $5CC
                              JU    $480
564: C4 40 07 90 01           BLS   8
                              AD    1
5C4: D4 12 F5 CB 21           TH   
                              JC    $5CB
                              XC    1
5D4: 00 E5 58 00 00           JU    $558
5CB: 00 40 07 E5 C4           BLS   8
                              JU    $5C4
;
; $3E8 - Opcode 018 - ALFO - Alphanumeric Output.
;
; Outputs the 5 characters in the A register to the selected output device.
;
; The manual says that the B register is unchanged, but this code will
; actually set B to $1C00000000 if all 5 characters are printed.  Or set it
; to zero if the print ended early due to a [I] terminator.
;
3E8: 00 84 6C E6 E0           CA    $46C        ; Set BI-5 to $1C00000000.
6E0: 77 25 80 01 24           XC    5           ; See $7B7 subroutine below.
                              CA    1           ; Load A register into BI-4.
                              XC    4
677: C4 C7 B7 C7 B7           JM    $7B7        ; Print the 5 characters
                              JM    $7B7        ; that were present in A.
6C4: CD C7 B7 C7 B7           JM    $7B7
                              JM    $7B7
6CD: 00 C7 B7 E4 80           JM    $7B7
                              JU    $480
46C: 1C 00 00 00 00           DW    $1C00000000
;
; $7B7 - Subroutine that prints an alphanumeric character.
;
; On entry, the high byte BI-4 contains the character to print.  On exit,
; it will be shifted up by 8 bits to prepare the next character.
;
; On entry, BI-5 is assumed to be set to $1C00000000, which is the
; character code for the [I] function key.  [I] is used as a terminator
; to stop character output before all 5 characters in Bi-4 are written.
;
7B7: 54 27 24 35 0A           XC    7           ; Put return address in BI-7.
                              XC    4           ; Get the character to print.
                              TE    5           ; Is BI-4 set to [I]?
754: 00 F5 58 E7 5B           JC    $558        ; Bail out if yes.
75B: 5B 70 00 F7 63           OAO               ; Print the char and rotate.
                              JC    $763
                              JU    $75B
763: 00 24 E0 07 00           XC    4           ; Put rotated A back into BI-4.
                              JU    7           ; Return from the subroutine.
558: 00 09 25 E4 80           CL                ; Set B to zero to indicate
                              XC    5           ; that the print ended early.
                              JU    $480
;
; $3E9 - Opcode 019 - SGET - Load Split Distribution Register.
;
3E9: 00 C6 70 E2 F4           JM    $670
                              JU    $2F4
;
; $3EA - Opcode 01A - SPUT - Store Split Distribution Register.
;
3EA: 00 80 01 E4 75           CA    1
475: 89 12 80 05 08           TH   
                              CA    5
                              AK   
489: 2D 40 13 90 01           BLS   20
                              AD    1
42D: 00 B0 01 E3 E5           ST    1
                              JU    $3E5
;
; $3EB - Opcode 01B - CDV - Check-Digit Verification.
;
3EB: 00 86 CA E5 CE           CA    $6CA
5CE: E9 20 09 B0 05           XC    0
                              CL   
                              ST    5
5E9: C7 60 81 B0 04           DLSC  2
                              ST    4
5C7: DE 21 B0 07 12           XC    1
                              ST    7
                              TH   
5DE: 48 F5 62 21 0A           JC    $562
                              XC    1
548: C8 6A 09 C6 ED           DRD   10
                              JM    $6ED
5C8: CA C6 ED C6 ED           JM    $6ED
                              JM    $6ED
5CA: 50 C6 ED C6 ED           JM    $6ED
                              JM    $6ED
550: E4 0B 25 68 00           CM   
                              XC    5
                              DRS   1
5E4: D0 60 00 90 05           DLS   1
                              AD    5
5D0: E8 B0 01 90 04           ST    1
                              AD    4
5E8: D9 0B 27 12 27           CM   
                              XC    7
                              TH   
                              XC    7
5D9: DD F5 DD 0B 0A           JC    $5DD
                              CM   
                              JU    $5DD
562: 00 0B 21 E5 48           CM   
                              XC    1
                              JU    $548
5DD: 00 B0 05 E4 80           ST    5
                              JU    $480
;
; $3EC - Opcode 01C - DUPE - Duplicate data with even parity.
;
3EC: 00 86 F0 E2 74           CA    $6F0
274: D0 92 F9 B0 04           AD    $2F9
                              ST    4
2D0: 00 14 80 04 0D           TP   
                              CA    4
                              JA
6F0: 00 40 00 00 00           DW    $0040000000
2F9: 58 00 D2 88 14           DW    $5800D28814
;
; $3ED - Opcode 01D - DUPO - Duplicate data with odd parity.
;
3ED: 00 09 E2 74 00           CL   
                              JU    $274
;
; $3EE - Opcode 01E - SPEC - Single character output with no parity.
;
3EE: 00 80 01 E3 FD           CA    1
3FD: 00 40 1F E4 A4           BLS   32
4A4: A4 70 C0 F4 80           OA   
                              JC    $480
                              JU    $4A4
;
; $3EF - Opcode 01F - SCLR - ???
;
3EF: 00 C6 65 E4 34           JM    $665
434: 49 84 3F B0 05           CA    $43F
                              ST    5
449: 14 83 87 B0 00           CA    $387
                              ST    0
414: 2B 68 03 B0 07           DRS   4
                              ST    7
42B: 3C 3D F4 13 0A           TG    5
                              JC    $413
43C: 4B 60 03 0B 0A           DLS   4
                              CM   
44B: D9 90 00 3D 0A           AD    0
                              TG    5
4D9: 67 F4 13 10 08           JC    $413
                              SK   
                              AK   
467: 8B 22 83 83 10           XC    2
                              CA    $383
                              SK   
48B: 19 08 0B 25 0A           AK   
                              CM   
                              XC    5
419: 68 82 D6 B0 01           CA    $2D6
                              ST    1
468: 7D 90 02 21 0A "         AD    2
                              XC    1
                              JU    $47D
;
; $3F0 - Opcode 020 - ???
;
3F0: 00 83 BE E4 C4           CA    $3BE
4C4: 00 40 13 E4 DF           BLS   20
4DF: 80 90 02 0A 22           AD    2
                              XC    2
                              JU    $480
;
; $700 - Print the number in S0 using the edit word formatting rules in S1.
;
; The edit word in S1 defines how the number is to be formatted for output.
;
; If the MSB (bit 39) is set, then the number should have a leading sign.
; The remainder of the edit word is a set of 3-bit edit rules for each
; of the digits or special characters to print.
;
;   000 - Print a space.
;   001 - ???
;   010 - Print a decimal point and then print a decimal digit.
;   011 - Print a space and then print an octal digit.
;   100 - Decimal digit.
;   101 - ???
;   110 - Octal digit.
;   111 - Hexadecimal digit.
;
700: 1B 21 40 00 21           XC    1           ; Shift the edit word in S1
                              BLS   1           ; up by 1 bit.
                              XC    1
71B: 9C B4 FE F7 9B           ST    $4FE        ; Store return address to $4FE.
                              JC    $79B        ; Jump if MSB of edit word is 1.
79C: 30 09 21 11 0A           CL   
                              XC    1
                              TZ   
730: BB F4 FE 40 00           JC    $4FE        ; Return if edit word is now 0.
                              BLS   1           ; Decode next 3-bit edit rule.
7BB: 46 F7 3F 40 00           JC    $73F
                              BLS   1           ; Edit rule is 0XX.
746: D1 F7 CA 40 00           JC    $7CA
                              BLS   1           ; Edit rule is 00X.
7D1: 5D F7 D5 21 0A           JC    $7D5
                              XC    1           ; Edit rule is 000 - space.
75D: 5D 70 00 F7 9C           OAO               ; Print the character in A.
                              JC    $79C
                              JU    $75D
73F: 4B 40 00 F7 47           BLS   1           ; Edit rule is 1XX.
                              JC    $747
74B: D6 40 00 F5 D3           BLS   1           ; Edit rule is 10X.
                              JC    $5D3
7D6: 00 62 00 E5 5E           DLD   1           ; Edit rule is 100 - dec digit.
55E: A9 21 40 10 0A           XC    1
                              BLS   17
5A9: 00 95 2D 0D 00           AD    $52D        ; Load $601+digit*2 into A
                              JA                ; and go print the high byte.
52D: 0A 86 01 E7 5D           DW    $0A8601E75D
5D3: A6 42 05 21 0A           BLD   6           ; Edit rule is 101.
                              XC    1
5A6: 00 40 1F E7 5D           BLS   32
                              JU    $75D
747: D2 40 00 F7 4F           BLS   1           ; Edit rule is 11X.
                              JC    $74F
7D2: 00 42 02 E5 5E           BLD   3           ; Edit rule is 110,
                              JU    $55E        ; which is an octal digit.
74F: 00 42 03 E5 5E           BLD   4           ; Edit rule is 111,
                              JU    $55E        ; which is a hexadecimal digit.
7CA: D7 40 00 F7 52           BLS   1           ; Edit rule is 01X.
                              JC    $752
7D7: D7 78 3B F7 D6           OI    $3B         ; Edit rule is 010.
                              JC    $7D6        ; Print a decimal point
                              JU    $7D7        ; followed by a decimal digit.
752: 52 78 80 F7 D2           OI    $80         ; Edit rule is 011.
                              JC    $7D2        ; Print a space, then print an
                              JU    $752        ; octal digit.
7D5: D5 78 80 F5 5D           OI    $80         ; Edit rule is 001.
                              JC    $55D        ; Output a space.
                              JU    $7D5
55D: A5 21 48 81 18           XC    1
                              BRSK  2
                              LA    0
5A5: 31 21 F7 AC 0A           XC    1
                              JC    $7AC
531: 44 40 02 48 85           BLS   3
                              BRSK  6
                              JU    $544
7AC: BF 10 48 85 0A           SK   
                              BRSK  6
                              JU    $7BF
;
; $79B - Output a number where the edit word has the MSB set.
;
; This is the case when the number should have a leading sign.  Either a
; space or a minus sign is printed and then the rest of the number is
; printed normally.
;
79B: AA 80 00 12 09           CA    0           ; Fetch the number from S0.
                              TH                ; Is it negative (MSB is set)?
                              CL                ; Load a space for +ve sign.
7AA: 00 F7 AE E7 31           JC    $7AE        ; Jump to $7AE if negative.
731: 31 70 00 F6 B9           OAO               ; Output the sign character.
                              JC    $6B9
                              JU    $731
6B9: D7 48 83 20 21           BRSK  4
                              XC    0
                              XC    1
6D7: 00 6A 0B E7 BF           DRD   12
7BF: 00 21 E7 9C 00           XC    1
                              JU    $79C
7AE: 66 40 A5 20 0B           BLSK  38          ; Effectively loads '-' into A.
                              XC    0
                              CM                ; Negate the number to output.
766: 00 20 E7 31 00           XC    0
                              JU    $731        ; Go back to print the '-' sign.
;
; $699 - Print a register number followed by '#'.
;
699: F1 B4 F1 84 ED           ST    $4F1        ; Store return address in $4F1.
                              CA    $4ED        ; Check the register mode.
6F1: 7E 11 F6 79 12           TZ                ; Is it hexadecimal mode?
                              JC    $679        ; Yes, jump to $679.
                              TH                ; Program or storage registers?
67E: 7B 84 F4 F6 F9           CA    $4F4
                              JC    $6F9        ; Jump to $5F9 if storage.
67B: 9C 96 9B 97 09           AD    $69B
                              AD    $709
69C: 00 F6 A2 E7 0C           JC    $6A2
                              JU    $70C        ; Print "ERR" and stop.
679: A6 84 F4 40 1B           CA    $4F4
                              BLS   28
6A6: B8 B0 00 96 B4           ST    0
                              AD    $6B4
6B8: C3 F7 0C 85 BF           JC    $70C        ; Print "ERR" and stop.
                              CA    $5BF
6C3: 00 E6 CC 00 00           JU    $6CC
6CC: A5 B0 01 C7 00           ST    1
                              JM    $700        ; Print the number in S1.
6A5: A5 78 0B F4 F1           OI    $0B         ; Print a '#'.
                              JC    $4F1        ; Return from the subroutine.
                              JU    $6A5
6A2: BC 60 08 B0 00           DLS   9
                              ST    0
6BC: 00 86 C8 E6 CC           CA    $6C8
                              JU    $6CC
6F9: A4 96 FE 97 86           AD    $6FE
                              AD    $786
6A4: 00 E6 9C 00 00           JU    $69C
;
5BF: 7F C0 00 00 00           DW    $7FC0000000
69B: FF FF FF FC 80           DW    $FFFFFFFC80
6B4: 00 10 00 00 00           DW    $0010000000
6C8: C9 00 00 00 00           DW    $C900000000
5FE: 10 97 02 11 0A           DW    $109702110A
709: 00 00 00 00 80           DW    $0000000080
786: 00 00 00 00 40           DW    $0000000040
;
; $795 - Check if the address in $4F4 is greater than or equal to $3BF.
; If it is, then return with K set to 1.  Otherwise increment the address
; in $4F4 and return with K set to 0.
;
795: F4 20 84 E9 21           XC    0           ; Put return address into S0.
                              CA    $4E9
                              XC    1
7F4: 23 84 F4 39 0A           CA    $4F4        ; Compare value of $4F4
                              TG    1           ; with S1 = $3BF.
723: B0 F0 00 10 08           JC    0
                              SK                ; Increment $4F4.
                              AK
7B0: 00 B4 F4 E0 00           ST    $4F4
                              JU    0           ; Return from the subroutine.
4E9: 00 00 00 03 BF           DW    $00000003BF
;
; $72E - Reads the word at the memory address in $4F4 into $4FD.
;
72E: 45 20 86 BB 22           XC    0           ; Put return address into S0.
                              CA    $6BB
                              XC    2           ; Copy $6BB instruction into S2.
745: A2 84 F4 40 07           CA    $4F4        ; Get the address to read and
                              BLS   8           ; add it to the instruction
7A2: B5 97 A6 B0 01           AD    $7A6        ; at $7A6.
                              ST    1           ; Put the new instruction in S1
7B5: 00 E0 01 00 00           JU    1           ; and then execute it.
6BB: 00 B4 FD E0 00           ST    $4FD
                              JU    0
7A6: 02 0F 80 00 0F           BI
                              CA    $000        ; Replaced with address to read.
                              BI
                              JU    2
;
; $6A1 - Prints the value in $4FD.
;
6A1: A9 B4 F1 84 FD           ST    $4F1        ; Put return address in $4F1.
                              CA    $4FD        ; Get the value to print.
6A9: 6B 20 84 E6 0A           XC    0           ; Put it into S0.
                              CA    $4E6        ; Get the number format rules.
66B: FB B0 01 48 01           ST    1           ; Put them into S1.
                              BRS   2           ; Is the edit word octal?
6FB: 00 F7 A8 E7 A9           JC    $7A8        ; Jump to $7A8 if it is.
7A9: 00 C7 00 E4 F1           JM    $700        ; Print the number in S0.
                              JU    $4F1        ; Return from subroutine.
;
; Special case for printing octal.  Deal with the high bit by printing
; either a space or a '1'.  Then print the rest of the word.
;
7A8: BC 20 40 00 20           XC    0           ; Shift the number up by 1 bit.
                              BLS   1
                              XC    0
7BC: CE 48 80 48 06           BRSK  1           ; Turn the bit into SP or '1'.
                              BRS   7
7CE: CE 70 00 F7 A9           OAO               ; Print the character.
                              JC    $7A9        ; Jump to $7A9 when complete.
                              JU    $7CE
;
; $670 - Loads the distribution register with address V07 into A.
;
670: 00 B0 03 E2 83           ST    3           ; Put return address in S3.
283: 8F 83 87 92 0B           CA    $387        ; Get the value of V07.
                              AD    $20B        ; Is V07 < 2000?
28F: 3D F4 13 92 B9           JC    $413        ; If not, jump to $413.
                              AD    $2B9        ; Restore the value of V07.
23D: 62 40 17 92 5C           BLS   24          ; Set up a memory fetch.
                              AD    $25C
262: 00 0D 00 00 00           JA                ; Execute the memory fetch.
413: 00 07 03 E7 FF           HH    7           ; Halt with error code 7.
                              HH    3           ; Resuming halts again with 3.
                              JU    $7FF        ; And then we re-init OPUS.
20B: FF FF FF F8 30           DW    $FFFFFFF830 ; -2000 as a constant.
2B9: 00 00 00 07 D0           DW    $00000007D0 ; +2000 as a constant.
25C: 88 00 21 E0 03 "8 J.3"   DW    $880021E003
;
; $6BF - Read a number and write it to the next storage register.
;
6BF: 6A B4 EC 84 E6           ST    $4EC        ; Store return address in $4EC.
                              CA    $4E6        ; Decimal or octal mode?
66A: F5 12 F6 F2 0A           TH   
                              JC    $6F2        ; Jump to $6F2 if decimal.
6F5: A7 48 01 F7 A3           BRS   2           ; Octal or hexadecimal mode?
                              JC    $7A3        ; Jump to $7A3 if octal.
6A7: 00 C5 85 E7 A7           JM    $585        ; Read hexadecimal number.
7A7: 33 F7 0C 11 0A           JC    $70C        ; Bail out on error.
                              TZ   
733: B4 F7 B4 C5 89           JC    $7B4
                              JM    $589
                              JU    $7B4
6F2: 00 C5 83 E7 A7           JM    $583        ; Read decimal number.
                              JU    $7A7
7A3: 00 C5 84 E7 A7           JM    $584        ; Read octal number.
                              JU    $7A7
7B4: 28 84 EF 48 07           CA    $4EF
                              BRS   8
728: B6 F5 BC 48 00           JC    $5BC
                              BRS   1
7B6: 00 F7 0C E6 BD           JC    $70C
6BD: 7A C7 8A 84 F4           JM    $78A
                              CA    $4F4
67A: FA 10 08 B4 F4           SK   
                              AK   
                              ST    $4F4
6FA: A8 C5 28 C6 99           JM    $528
                              JM    $699
6A8: 00 E4 EC 00 00           JU    $4EC        ; Return from the subroutine.
;
; $4BC - ???
;
4BC: 8D B4 EC C2 70           ST    $4EC        ; Store return address in $4EC.
                              JM    $270
48D: 00 F4 91 E4 15           JC    $491
415: 91 C4 25 B4 F8           JM    $425
                              ST    $4F8
                              JU    $491
491: 8E 84 EF 48 05           CA    $4EF
                              BRS   6
48E: 00 F4 92 E4 95           JC    $492
495: 8F 84 F2 0B 0A           CA    $4F2
                              CM   
48F: 17 F4 17 C2 29           JC    $417
                              JM    $229
                              JU    $417
417: 00 C7 8A E7 B4           JM    $78A
7B4: 28 84 EF 48 07           CA    $4EF
                              BRS   8
728: B6 F5 BC 48 00           JC    $5BC
                              BRS   1
7B6: 00 F7 0C E6 BD           JC    $70C
6BD: 7A C7 8A 84 F4           JM    $78A
                              CA    $4F4
67A: FA 10 08 B4 F4           SK   
                              AK   
                              ST    $4F4
6FA: A8 C5 28 C6 99           JM    $528
                              JM    $699
6A8: 00 E4 EC 00 00           JU    $4EC        ; Return from the subroutine.
492: 26 24 11 F4 95           XC    4
                              TZ   
                              JC    $495
426: 90 94 61 24 0A           AD    $461
                              XC    4
490: 00 C5 36 E4 EC           JM    $536
                              JU    $4EC        ; Return from the subroutine.
5BC: 00 C7 8A E7 6A           JM    $78A
                              JU    $76A
;
; $270 - Read in a mnemonic opcode.
;
270: AE B4 F3 09 10           ST    $4F3        ; Store return address in $4F3.
                              CL   
                              SK   
2AE: C8 40 84 B0 00           BLSK  5
                              ST    0           ; Set S0 to 16.
2C8: C8 5C 00 F2 50           CIOP              ; Read a character from input.
                              JC    $250
                              JU    $2C8
250: B0 B0 01 40 1F           ST    1           ; Store character in S1.
                              BLS   32
2B0: B0 70 00 F2 B8           OAO               ; Each the character.
                              JC    $2B8
                              JU    $2B0
2B8: DD 85 4E 90 01           CA    $54E        ; Check if char code >= $41.
                              AD    1
2DD: 69 F7 0C 94 E4           JC    $70C        ; Print "ERR" and exit if it is.
                              AD    $4E4        ; Read the parse rule at
269: B1 B0 06 C0 06           ST    6           ; $600 + char into A.
                              JM    6
2B1: 32 B4 EF 48 00           ST    $4EF        ; Store the parse rule to $4EF.
                              BRS   1           ; Is bit 0 set to 1?
232: CF F2 B6 48 01           JC    $2B6        ; If yes, a valid opcode letter.
                              BRS   2           ; Is bit 3 set to 1?
2CF: 00 F4 D3 E7 0C           JC    $4D3        ; If yes, we have a terminator.
                              JU    $70C        ; Print "ERR" and exit.
2B6: E6 20 40 05 0A           XC    0           ; Shift S0 up by 6 bits.
                              BLS   6
2E6: B2 F7 0C 90 01           JC    $70C        ; Stop if opcode is too long.
                              AD    1           ; Add the current char to S0.
2B2: 00 B0 00 E2 C8           ST    0
                              JU    $2C8        ; Go back for the next char.
;
; Once we get here, we have the characters of the typed opcode in S0.
; Up to 5 characters may be present in the opcode.
;
4D3: 97 B0 02 80 00           ST    2           ; Save the parse rule in S2.
                              CA    0
497: 97 40 05 F4 A6           BLS   6           ; Pad opcode in S0 with spaces
                              JC    $4A6        ; to left-align it in the word.
                              JU    $497
4A6: 3B 40 03 11 20           BLS   4
                              TZ                ; Is the opcode all spaces?
                              XC    0
43B: 98 F4 F3 84 E8           JC    $4F3        ; If yes, return from subr.
                              CA    $4E8        ; Was the OPUS command S or Q?
498: 27 94 1C F4 20           AD    $41C
                              JC    $420        ; Jump to $420 if it was Q.
427: 27 78 C8 F4 2F           OI    $C8         ; Move print head to column 25.
                              JC    $42F
                              JU    $427
42F: A0 C2 12 B0 03           JM    $212
                              ST    3
4A0: B4 40 08 F4 B0           BLS   9
                              JC    $4B0
4B4: CD 22 48 05 22           XC    2
                              BRS   6
                              XC    2
4CD: 00 F4 D1 E7 0C           JC    $4D1
                              JU    $70C
420: 20 78 CE F4 2F           OI    $CE         ; Move print head to column 43.
                              JC    $42F
                              JU    $420
4B0: 47 80 02 48 05           CA    2
                              BRS   6
447: 00 F4 CB E4 CF           JC    $4CB
4CF: A7 09 25 82 23           CL   
                              XC    5
                              CA    $223
4A7: 00 1A E4 4C 00           LA    2
44C: 4A F7 0C 84 C6           JC    $70C
                              CA    $4C6
44A: 9C 2B 48 09 0A           XT    3
                              BRS   10
49C: 35 90 05 25 09           AD    5
                              XC    5
                              CL   
435: 00 B4 F2 E4 F3           ST    $4F2
                              JU    $4F3        ; Return from the subroutine.
4CB: 9D C5 83 27 0B           JM    $583
                              XC    7
                              CM   
49D: 9E F7 0C 84 EF           JC    $70C
                              CA    $4EF
49E: CF 48 02 13 22           BRS   3
                              RK   
                              XC    2
                              JU    $4CF
4D1: DC 40 00 F7 59           BLS   1
                              JC    $759
4DC: 99 40 00 F6 64           BLS   1
                              JC    $664
499: 9B C5 84 87 86           JM    $584
                              CA    $786
49B: 31 25 F7 0C 3D           XC    5
                              JC    $70C
                              TG    5
431: 45 25 27 F7 0C           XC    5
                              XC    7
                              JC    $70C
445: 00 11 E4 4C 00           TZ   
                              JU    $44C
664: E3 C5 85 87 09           JM    $585
                              CA    $709
6E3: 00 E4 9B 00 00           JU    $49B
70C: 37 86 AA B0 00           CA    $6AA
                              ST    0
737: F5 B4 ED 7E 41           ST    $4ED
                              IS    $41
7F5: 00 C6 D4 E7 7B           JM    $6D4
77B: 87 7E C0 7E 49           IS    $C0
                              IS    $49
787: 6C 87 10 B4 E7           CA    $710
                              ST    $4E7
76C: 88 87 F0 B4 FF           CA    $7F0
                              ST    $4FF
788: 14 C7 8A 09 10           JM    $78A
                              CL   
                              SK   
714: 72 08 B4 ED 0A           AK   
                              ST    $4ED
772: 00 87 F6 E7 7A           CA    $7F6
77A: 00 B4 E6 E7 6A           ST    $4E6
76A: 1D 7E 41 48 A7           IS    $41
                              BRSK  40
71D: 29 40 01 F7 1D           BLS   2
                              JC    $71D
729: DC 7E 49 48 A7           IS    $49
                              BRSK  40
7DC: 68 40 01 F7 DC           BLS   2
                              JC    $7DC
768: 6A 5C 00 F5 F0           CIOP 
                              JC    $5F0
                              JU    $76A
5F0: 7B 12 F7 0C 0A           TH   
                              JC    $70C
57B: 1E 40 17 B0 02           BLS   24
                              ST    2
51E: ED 40 07 B4 E8           BLS   8
                              ST    $4E8
5ED: ED 70 00 F5 75           OAO  
                              JC    $575
                              JU    $5ED
575: 96 48 89 1A 22           BRSK  10
                              LA    2
                              XC    2
596: 00 F5 9A E7 6A           JC    $59A
                              JU    $76A
59A: 00 95 9E 0D 00           AD    $59E
                              JA
759: E4 40 00 F7 61           BLS   1
                              JC    $761
7E4: 6F 40 00 F7 EC           BLS   1
                              JC    $7EC
76F: C3 C5 83 F7 0C           JM    $583
                              JC    $70C
7C3: D0 87 C7 2B 0A           CA    $7C7
                              XT    3
7D0: 00 48 13 E4 9B           BRS   20
                              JU    $49B
761: C8 C5 83 F7 0C           JM    $583
                              JC    $70C
7C8: 58 80 05 40 00           CA    5
                              BLS   1
758: E9 90 05 B0 05           AD    5
                              ST    5
7E9: 49 60 00 90 05           DLS   1
                              AD    5
749: 60 97 4D B0 00           AD    $74D
                              ST    0
760: C9 68 01 B0 05           DRS   2
                              ST    5
7C9: D8 60 01 0B 0A           DLS   2
                              CM   
7D8: EE 90 00 90 05           AD    0
                              AD    5
7EE: CB 92 73 11 0A           AD    $273
                              TZ   
7CB: 00 F7 C3 E7 0C           JC    $7C3
                              JU    $70C
7EC: C4 C5 83 84 A2           JM    $583
                              CA    $4A2
7C4: 00 E4 9B 00 00           JU    $49B
;
41C: D9 00 00 00 00           DW    $D900000000
4E4: 06 26 0A 86 41           DW    $06260A8641
;
; $212 - ???
;
212: 7B B4 F0 87 F7           ST    $4F0        ; Store return address in $4F0.
                              CA    $7F7        ; Set S1 to -1024.
27B: 92 21 82 8A 0A           XC    1
                              CA    $28A
292: 00 94 96 0D 00           AD    $496
                              JA                ; XC 3, read $600, jump to $40C.
40C: 1D B0 05 19 0A           ST    5
                              LA    1
41D: AE F7 0C 30 23           JC    $70C        ; Bail out on error.
                              TE    0
                              XC    3
4AE: 00 F4 32 E2 92           JC    $432
                              JU    $292
432: 46 23 84 3E 1B           XC    3
                              CA    $43E
                              LA    3
446: 5A 39 D4 D4 0A           TG    1
                              AC    $4D4
45A: 00 94 DE 0D 00           AD    $4DE
                              JA
28A: 23 85 FE E4 0C           DW    $2385FEE40C
43E: 00 FF FF 00 00           DW    $00FFFF0000
496: 00 00 02 00 00           DW    $0000020000
4D4: FF FF FE 00 00           DW    $FFFFFE0000
4DE: 0A 00 01 E4 F0           DW    $0A0001E4F0
7F7: FF FF FF FC 00           DW    $FFFFFFFC00
;
; $402 - Print the number in S1 using the formatting edit word in S0.
;
402: 00 B4 F9 E5 2A           ST    $4F9        ; Store return address in $4F9.
52A: 3C 80 01 B0 07           CA    1           ; Load the number from S1.
                              ST    7           ; Copy it to S7.
53C: C9 0B 12 F6 C6           CM                ; Calculate the absolute
                              TH                ; value of S1 and put it
                              JC    $6C6        ; back into S1.
5C9: 00 B0 01 E6 C6           ST    1
6C6: D5 86 CA 20 0A           CA    $6CA        ; ???
                              XC    0
6D5: 92 6A 09 40 03           DRD   10
                              BLS   4
692: A3 B0 04 F6 A0           ST    4
                              JC    $6A0
6A3: AF 40 01 F6 AC           BLS   2
                              JC    $6AC
6AF: C0 40 00 23 0A           BLS   1
                              XC    3
6C0: 93 87 78 08 0A           CA    $778        ; Set A to -1.
                              AK   
693: 00 23 21 E5 D6           XC    3
                              XC    1
5D6: 68 09 21 40 00           CL   
                              XC    1
                              BLS   1
568: F4 F5 EC 40 00           JC    $5EC
                              BLS   1
5F4: 81 F5 F8 40 00           JC    $5F8
                              BLS   1
581: 95 80 07 B0 01           CA    7           ; Recover the original number.
                              ST    1           ; Put it back into S1.
595: 20 F5 99 12 0A           JC    $599        ; Skip if no sign required.
                              TH                ; Is the value negative?
520: 00 F5 24 E5 27           JC    $524        ; If yes, jump to $524.
527: 27 78 80 F5 99           OI    $80         ; Print a space.
                              JC    $599
                              JU    $527
524: 24 78 20 F5 99           OI    $20         ; Print a minus sign '-'.
                              JC    $599
                              JU    $524
599: 2E 24 0B 12 0A           XC    4
                              CM   
                              TH   
52E: 2E F4 F9 78 1C           JC    $4F9        ; Return from subroutine.
                              OI    $1C         ; Print the I function key.
                              JU    $52E
5EC: FA 40 00 F6 74           BLS   1
                              JC    $674
5FA: 92 40 00 F7 82           BLS   1
                              JC    $782
592: A7 23 12 23 0A           XC    3
                              TH   
                              XC    3
5A7: 00 F5 2B E5 AE           JC    $52B
5AE: AE 78 9B F6 94           OI    $9B         ; Print a comma.
                              JC    $694
                              JU    $5AE
694: 00 62 00 E5 3D           DLD   1
53D: CF 21 11 D0 03           XC    1
                              TZ   
                              AC    3
5CF: 00 95 53 0D 00           AD    $553        ; Look up the digit handler
                              JA                ; from the table t $503.
52B: B9 48 02 95 B5           BRS   3
                              AD    $5B5
5B9: 00 E5 3D 00 00           JU    $53D
5F8: 16 40 00 F7 01           BLS   1
                              JC    $701
516: 16 78 91 F6 FC           OI    $91
                              JC    $6FC
                              JU    $516
6FC: 94 23 09 23 0A           XC    3
                              CL   
                              XC    3
                              JU    $694
674: FF 40 00 F6 FC           BLS   1
                              JC    $6FC
6FF: 00 E6 94 00 00           JU    $694
6A0: B1 40 02 23 0A           BLS   3
                              XC    3
6B1: 00 86 B5 E6 93           CA    $6B5
                              JU    $693
6AC: C1 40 00 23 0A           BLS   1
                              XC    3
6C1: 00 86 C5 E6 93           CA    $6C5
                              JU    $693
701: 01 78 3B F6 FC           OI    $3B
                              JC    $6FC
                              JU    $701
782: 15 62 00 21 0A           DLD   1
                              XC    1
715: 00 E5 D6 00 00           JU    $5D6
50A: 0A 78 07 F7 0B           OI    $07         ; Print a '7' ???
                              JC    $70B
                              JU    $50A
70B: 1F 23 09 23 0A           XC    3
                              CL   
                              XC    3
71F: 00 E5 D6 00 00           JU    $5D6
6CA: 28 00 00 00 00           DW    $2800000000
553: 0A 0A 0A 85 03           DW    $0A0A0A8503
;
; Table of routines to print decimal digits.
;
503: 0A 78 10 F7 0B           OI    $10
                              JC    $70B
                              JU    $50A
504: 0A 78 01 F7 0B           OI    $01
                              JC    $70B
                              JU    $50A
505: 0A 78 02 F7 0B           OI    $02
                              JC    $70B
                              JU    $50A
506: 0A 78 83 F7 0B           OI    $83
                              JC    $70B
                              JU    $50A
507: 0A 78 04 F7 0B           OI    $04
                              JC    $70B
                              JU    $50A
508: 0A 78 85 F7 0B           OI    $85
                              JC    $70B
                              JU    $50A
509: 0A 78 86 F7 0B           OI    $86
                              JC    $70B
                              JU    $50A
50B: 0A 78 08 F7 0B           OI    $08
                              JC    $70B
                              JU    $50A
50C: 0A 78 89 F7 0B           OI    $89
                              JC    $70B
                              JU    $50A
;
; $789 - Select the current input and output devices in $4E7.
;
789: 18 B0 00 7E C0           ST    0           ; Store return address in S0.
                              IS    $C0         ; Select device $C0.
                              JU    $718
718: 0A 84 E7 40 17           CA    $4E7        ; Select the current input and
                              BLS   24          ; output devices.
                              JU    $70A
