;
; Global Variables:
;
;   $300    Start of the program area, extends to $37F.
;   $380    Start of the storage area for Vnn registers, extends to $3BF.
;   $4E6    Decimal, octal, or hexadecimal number format.
;   $4E7    ???
;   $4E8    Current command character, aligned in bits 32..39.
;   $4EA    ???
;   $4EB    ???
;   $4ED    Mode: 1 = program registers, -1 = storage registers, 0 = hex mode.
;   $4F1    Link address for subroutines.
;   $4F2    Link address for subroutines.
;   $4F4    Register number that was entered by the user.
;   $4FB    Return instruction for the high-level interpreter, used by JR & JMK.
;   $4FC    Return address for the high-level interpreter, used by JR & JMK.
;   $4FD    Contents of a register when fetching from memory.
;   $4FE    Link address for low-level subroutines.
;   $4FF    Character input routine that waits for input and then jumps to $50E.
;
; The block interchange contains the high-level language's state:
;
;   BI-1    A register
;   BI-2    Current instruction word being executed, 10 bits per instruction
;   BI-5    B register
;   BI-6    Address of the current instruction word being executed
;

;
; $FFF - Main entry point to OPUS upon a HALT, READY, RUN sequence.
;
; On entry, A = $FFFFFFFFFF and K = 1.
;
FFF: 00 E7 FF 10 08           JU    $7FF
7FF: 74 B4 EA 09 08           ST    $4EA        ; Set $4EA to All-1's.
                              CL   
                              AK   
774: 7B B4 EB 0F 0A           ST    $4EB        ; Set $4EB to 1.
                              BI                ; Block interchange.
77B: 87 7E C0 7E 49           IS    $C0         ; Reset all I/O devices.
                              IS    $49         ; Select keyboard and printer.
787: 6C 87 10 B4 E7           CA    $710        ; Load $49 into A
                              ST    $4E7        ; and store it to $4E7.
76C: 88 87 F0 B4 FF           CA    $7F0        ; Set $4F0 to a character
                              ST    $4FF        ; input routine.
788: 14 C7 8A 09 10           JM    $78A        ; Print a CRLF.
                              CL   
                              SK   
714: 72 08 B4 ED 0A           AK                ; Store A = 1 to $4ED
                              ST    $4ED        ; (select program registers).
772: 00 87 F6 E7 7A           CA    $7F6        ; Set the number format in
77A: 00 B4 E6 E7 6A           ST    $4E6        ; $4E6 to "octal".
;
; Main input loop.
;
76A: 1D 7E 41 48 A7           IS    $41         ; Select the printer.
                              BRSK  40          ; Set A to all 1 bits.
71D: 29 40 01 F7 1D           BLS   2           ; Delay loop, 20 iterations.
                              JC    $71D
729: DC 7E 49 48 A7           IS    $49         ; Select keyboard and printer.
                              BRSK  40          ; Set A to all 1 bits.
7DC: 68 40 01 F7 DC           BLS   2           ; Delay loop, 20 iterations.
                              JC    $7DC
768: 6A 5C 00 F5 F0           CIOP              ; Input, odd parity.
                              JC    $5F0
                              JU    $76A        ; No input yet, loop again.
;
; Echo and dispatch the command that was typed from the main input loop.
;
5F0: 7B 12 F7 0C 0A           TH                ; Was there a parity error?
                              JC    $70C        ; Yes, jump tp $70C.
57B: 1E 40 17 B0 02           BLS   24          ; Shift char from bits 0..7 to
                              ST    2           ; bits 24..31 and store in S2.
51E: ED 40 07 B4 E8           BLS   8           ; Shift char to bits 32..39
                              ST    $4E8        ; and store into $4E8.
5ED: ED 70 00 F5 75           OAO               ; Echo the character.
                              JC    $575
                              JU    $5ED        ; Loop until output not busy.
710: 00 00 00 00 49           DW    $0000000049
7F0: 0A 5C 00 F5 0E           DW    $0A5C00F50E
;
; Dispatch the command based on the character in bits 24..31 S2.
; The code here is a little weird, but the overall effect is to do this:
;
;       if (ch >= 0100) {
;           // Character is out of range, no valid handler.
;           goto $76A;
;       }
;       S2 = memory[$600 + ch]
;       goto $790
;
; Effectively, load the handler for the command character (0 to 077) into
; S2 and jump to $790.  Characters 0100 and above are ignored as they only
; move the print head and don't do anything useful.
;
575: 96 48 89 1A 22           BRSK  10          ; Set A to $FFC0000000.
                              LA    2           ; AND A with S2 (char << 24).
                              XC    2
596: 00 F5 9A E7 6A           JC    $59A        ; Skip if A AND S2 was zero.
                              JU    $76A        ; Invalid command character.
59A: 00 95 9E 0D 00           AD    $59E        ; Look up the command handler
                              JA                ; table and jump to $790.
70C: 37 86 AA B0 00           CA    $6AA        ; Load the "ERR" message.
                              ST    0           ; Store to S0 and $4ED.
737: F5 B4 ED 7E 41           ST    $4ED
                              IS    $41         ; Select the printer.
7F5: 00 C6 D4 E7 7B           JM    $6D4        ; Print "ERR".
                              JU    $77B        ; Error printed, go back.
6AA: 00 00 35 29 29 "  ERR"   DW    $0000352929
;
; $59E encodes the instruction sequence CA $600 / XC 2 / JU $790 which
; performs a memory pointer lookup on $600 + ch.
;
59E: 86 00 22 E7 90           DW    $860022E790
;
; Dispatch the command word in S2.  If bit 0 is zero or bit 3 is 1,
; then the command character was unrecognised.  Jump back to the main
; input loop at $76A for unrecognised commands.
;
790: 9F 87 11 2A 0A           CA    $711
                              XT    2
79F: 2A 48 00 F7 27           BRS   1
                              JC    $727
72A: 00 E7 6A 00 00           JU    $76A
727: 35 48 02 F7 6A           BRS   3
                              JC    $76A
735: 00 97 B9 0D 00           AD    $7B9
                              JA
7B9: 0A 78 41 F6 80           DW    $0A7841F680
70A: 00 97 13 0D 00           AD    $713
                              JA
711: 00 00 00 03 FF           DW    $00000003FF
713: 7E 00 E0 00 00           DW    $7E00E00000
;
; $600 - Character information table.  Different bits of this table
; provide information about characters for the command loop, number
; parsing, number formatting, etc.
;
; Each word in this table provides information about the characters
; 000 to 077 (octal).  This table is used to help dispatch commands.
;
;   Bit     Meaning
;   0       1 for command character, 0 for parsed digit value
;   1       ???
;   2       ???
;   3       0 if the character is valid as a command, 1 if valid as a digit.
;   4-9     N, address of the command handler ($680 + N) if bit 0 is 1.
            N, the parsed digit value if bit 0 is 0.
;   10-31   ???
;   32-39   Odd words map digits 0-9,A-F to their character code form.
;
; The high byte in words $601, $603, $605, etc provide the character codes
; for digits 0-9,A-F for use in number formatting.
;
600: 4B 58 C0 01 04     ; Space
601: 10 7F C0 00 18     ; 1             ; CORRUPT!  FIXME!
602: 7E 84 7D 00 28     ; 2             ; CORRUPT!  FIXME!
603: 01 50 00 80 3A     ; 3
604: 99 44 C0 00 48     ; 4
605: 02 42 01 80 58     ; 5
606: D1 49 C0 00 68     ; 6
607: 03 64 07 00 78     ; 7
608: 4F 1C 80 00 8A     ; 8
609: 04 64 09 00 9A     ; 9
60A: 85 99 C0 00 00     ; @ / CLEAR
60B: 05 48 0C 00 14     ; # / P0
60C: 86 48 80 00 F1     ; P1 - Read Program Tape         - Handler: $68F
60D: 06 48 0A 00 41     ; P2 - Verify Program Tape       - Handler: $684
60E: 85 49 C0 00 00     ; P3
60F: 07 48 0E 00 00     ; P4
610: 86 74 80 00 08     ; 0
611: 08 80 00 10 44     ; /
612: 49 50 00 00 B1     ; S - Store Instructions or Data - Handler: $68B
613: 09 44 04 00 71     ; T - Punch Program onto Tape    - Handler: $687
614: C9 50 00 00 01     ; U - ??? - Same as P            - Handler: $680
615: 31 44 03 00 A1     ; V - Select Storage Registers   - Handler: $68A
616: C7 3C C0 00 C1     ; W - Print Registers            - Handler: $68C
617: 32 44 02 00 D1     ; X - Print Register A           - Handler: $68D
618: 51 50 00 00 E1     ; Y - Print Register B           - Handler: $68E
619: 33 44 05 00 01     ; Z - ??? - Same as P            - Handler: $680
61A: 93 45 40 00 00     ; *
61B: 34 42 01 00 24     ; ,
61C: 5F 3C 80 00 24     ; I
61D: 35 80 00 04 44     ; II
61E: 5F 35 40 00 00     ; III
61F: 36 80 00 15 01     ; IIII - Run Application         - Handler: $690
620: CE 3A 40 00 02     ; - / Diamond
621: 00 80 00 20 11     ; J - Undocumented Command       - Handler: $681
622: C7 4D 00 00 21     ; K - Undocumented Command       - Handler: $682
223: 00 80 00 08 31     ; L - Punch Tape Leader          - Handler: $683
624: 97 7C 40 00 01     ; M - ??? - Same as P            - Handler: $680
625: 00 80 00 24 51     ; N - Select Decimal Format      - Handler: $685
626: 97 7C 80 00 61     ; O - Select Octal Format        - Handler: $686
627: 00 80 00 28 01     ; P - Select Program Registers   - Handler: $680
628: 86 90 00 00 81     ; Q - Change Register            - Handler: $688
629: 00 80 00 0C 91     ; R - Reset Memory               - Handler: $689
62A: 4A 2E 67 00 00     ; %
62B: 00 80 00 40 00     ; $
62C: CE 60 00 01 04     ; Index Left + Right
62D: 00 14 08 01 04     ; Index Right
62E: 4B 3E 40 00 00     ; Black Ribbon Print
62F: 00 80 00 38 00     ; Formup
630: 4B 39 80 00 00     ; &
631: 00 80 00 18 A9     ; A
632: E6 5C 40 00 B9     ; B
633: 00 80 00 2C C9     ; C
634: C6 10 00 00 D9     ; D
635: 00 80 00 1C E9     ; E
636: D1 3D 65 00 F9     ; F
637: 00 80 00 30 01     ; G - ??? - Same as P            - Handler: $680
638: 49 2C F1 95 11     ; H - Select Hexadecimal Format  - Handler: $691
639: 00 80 00 34 01     ; I - ??? - Same as P            - Handler: $680
63A: 9A 75 12 00 84     ;
63B: 00 80 00 3C 00     ; .
63C: CF 18 F3 00 00     ; Red Ribbon Print
63D: 00 80 00 45 04     ; Index Left
63E: D3 94 93 00 00     ; Backspace
63F: 00 80 00 4C 00     ; Carriage Open or Close
;
;
; $534 and $5BC - Control returns to one of these addresses when a command
; handler finishes processing.  Print a CRLF and jump back to the main loop.
;
534: 00 7E 49 E5 BC           IS    $49         ; Select keyboard and printer.
5BC: 00 C7 8A E7 6A           JM    $78A        ; Print a CRLF.
                              JU    $76A        ; Jump back to the main loop.
;
; $680 - Command handler for P, U, Z, G, I, M.
;
; P is "Select Program Registers".  Not sure what the other ones are for.
;
680: 00 87 8C E7 38           CA    $78C        ; Set $4ED to 1
738: 00 B4 ED E5 34           ST    $4ED        ; (select progream registers).
                              JU    $534
78C: 00 00 00 00 01           DW    $0000000001
;
; $681 - Command handler for J - Undocumented Command.
;
; All this seems to do is halt with code 7.  Not sure why this is useful.
;
681: 04 1F C6 5E 05           LA    7
                              JM    $65E
                              HH    5
65E: 00 07 07 E6 5E           HH    7
                              HH    7
                              JU    $65E
;
; $682 - Command handler for K - Undocumented Command.
;
; Not sure what this is doing.
;
; TODO
;
682: 1E 84 5D D2 1C           CA    $45D
                              AC    $21C
                              JU    $61E
;
; $683 - Command handler for L - Punch Tape Leader.
;
; TODO
;
683: 00 87 B8 E5 1C           CA    $7B8
51C: 00 F5 11 E4 F9           JC    $511
                              JU    $4F9
511: 22 21 12 F5 9F           XC    1
                              TH   
                              JC    $59F
522: 00 0B E5 9F 00           CM   
59F: 00 21 E4 F9 00           XC    1
4F9: 28 0A E4 80 25           NN
                              JU    $480
7B8: FF FF FF FF D8           DW    $FFFFFFFFD8
;
; $684 - Command handler for P2 - Verify Program Tape.
;
; TODO
;
684: 00 85 1D E5 29           CA    $51D
                              JU    $529
;
; $685 - Command handler for N - Select Decimal Format.
;
685: 00 87 42 E7 C6           CA    $742
7C6: 00 B4 E6 E5 34           ST    $4E6
                              JU    $534
;
; $742 - Edit word for formatting numbers in decimal.
;
; $C9148A4520 is 14442442442440 in octal which indicates:
;
;       1       Show the sign before the number
;       444     Decimal digits with leading zero suppression
;       244     Comma, then decimal digits with leading zero suppression
;       0       Trailing space
;
742: C9 14 8A 45 20           DW    $C9148A4520
;
; $686 - Command handler for O - Select Octal Format.
;
; $67B3D9ECF6 is 06366366366366 in octal which indicates:
;
;       0       No leading sign
;       6       Single octal digit
;       366     Comma and then three octal digits
;
686: 00 87 F6 E7 C6           CA    $7F6
                              JU    $7C6
7F6: 67 B3 D9 EC F6           DW    $67B3D9ECF6 ; Edit word for octal.
;
; $687 - Command handler for T - Punch Program onto Tape.
;
; TODO
;
687: 00 84 ED E5 23           CA    $4ED
                              JU    $523
;
; $688 - Command handler for Q - Change Register.
;
; TODO
;
688: 00 C5 76 E5 3F           JM    $576        ; Prompt for register number.
53F: B2 C5 35 C7 2E           JM    $535        ; Move print head to column 19.
                              JM    $72E        ; Read memory at $4F4 into $4FD.
5B2: C2 C5 3B F2 C3           JM    $53B        ; Are we in program reg mode?
                              JC    $2C3        ; Yes, jump to $2C3.
5C2: BD C6 A1 C5 37           JM    $6A1        ; Print the value in $4FD.
                              JM    $537
5BD: 00 C6 BF E5 3F           JM    $6BF
                              JU    $53F
2C3: 00 C2 2A E2 2E           JM    $22A
22E: A9 C4 0A 84 F8           JM    $40A
                              CA    $4F8
2A9: 31 B0 00 C2 2D           ST    0
                              JM    $22D
231: C5 C5 38 C4 BC           JM    $538
                              JM    $4BC
2C5: 00 F5 3F E2 2E           JC    $53F
                              JU    $22E
;
; $689 - Command handler for R - Reset Memory.
;
; Starts by printing "4DEB" to the console and then waits for the user to
; press a key.  Note: The programming manual states that this should print
; "RESET" rather than "4DEB".  Not sure why the discrepancy.
;
; If the user presses "SHIFT+P4", then the program and storage registers will
; be cleared.  Otherwise OPUS prints "ERR" and goes back to the main loop.
;
689: 00 C2 DA E5 34           JM    $2DA
                              JU    $534
2DA: 6F 24 84 48 20           XC    4           ; Shift return address into S4.
                              CA    $448        ; Print "4DEB", move to col 28.
                              XC    0
26F: 00 C6 D4 E4 58           JM    $6D4        ; Call print message routine.
458: 58 5C 00 F7 E0           CIOP              ; Wait for input.
                              JC    $7E0
                              JU    $458
7E0: EF 96 E4 11 0A           AD    $6E4        ; Was the key SHIFT+P4?
                              TZ   
7EF: 00 F6 B3 E7 0C           JC    $6B3
                              JU    $70C        ; No, print "ERR" and stop.
6B3: CF 87 C2 B0 01           CA    $7C2        ; Build a program in
                              ST    1           ; A, S0, S1, S2, S3 to
6CF: DE 87 D4 B0 02           CA    $7D4        ; reset the registers.
                              ST    2
6DE: 6F 86 62 B0 03           CA    $662
                              ST    3
66F: D0 87 73 B0 00           CA    $773
                              ST    0
6D0: 00 95 D7 E0 03           AD    $5D7
                              JU    3           ; Jump to the program we built.
448: 04 34 35 32 49 "4DEB."   DW    $0434353249
6E4: FF FF FF FF B1           DW    $FFFFFFFFB1 ; Negated SHIFT+P4 char code.
;
; The following words are loaded into A, S0, S1, S2, and S3 to create a
; loop that resets all program and storage registers, modifying the address
; each time through the loop.  Effectively the code is as follows:
;
;       S0 = $000707E3C0
;       A  = $000707E2FF
;   3:  SK                  ; Increment A.
;       AK
;       TE 0                ; Have we reached the end of the registers?
;   1:  JC 4                ; Return from subroutine at the end.
;       ST $300+N           ; Store the pattern in A to address $300+N.
;   2:  XC 1                ; Exchange A and S1.
;       SK                  ; Increment the instruction at address "1:".
;       AK
;       XC 1                ; Put the modified instruction back at address "1:".
;       JU 3                ; Back around for the next word.
;
5D7: FF FF FF FF 3F           DW    $FFFFFFFF3F
662: 01 10 08 30 0A           DW    $011008300A
773: 00 07 07 E3 C0           DW    $000707E3C0
7C2: 02 F0 04 B3 00           DW    $02F004B300
7D4: 03 21 10 08 21           DW    $0321100821
;
; $68A - Command handler for V - Select Storage Registers.
;
68A: 00 87 78 E7 38           CA    $778        ; Set $4ED to -1
                              JU    $738        ; (select storage registers).
778: FF FF FF FF FF           DW    $FFFFFFFFFF
;
; $68B - Command handler for S - Store Instructions or Data.
;
; TODO
;
68B: 00 C5 76 E2 46           JM    $576
                              JU    $246
;
; $68C - Command handler for W - Print Registers in a range.
;
68C: 00 C5 76 E5 41           JM    $576        ; Prompt for first register.
541: B3 C5 0F C7 8A           JM    $50F        ; Prompt for last register.
                              JM    $78A        ; Print CRLF.
5B3: BA C6 99 C5 35           JM    $699        ; Print the register number.
                              JM    $535        ; Move print head to column 19.
5BA: C0 C7 2E C5 3B           JM    $72E        ; Read memory at $4F4 into $4FD.
                              JM    $53B        ; Are we in program reg mode?
5C0: B8 F2 C7 C6 A1           JC    $2C7        ; Yes, jump to $2C7.
                              JM    $6A1        ; Print the value in $4FD.
5B8: B4 C7 8A C7 95           JM    $78A        ; Print CRLF.
                              JM    $795        ; Check for the end of all regs.
5B4: 00 F5 BC E5 B3           JC    $5BC        ; Jump to $5BC if we are done.
                              JU    $5B3        ; Go back for the next register.
2C7: 00 C2 2A E4 AF           JM    $22A
4AF: A8 C4 0A 84 F8           JM    $40A
                              CA    $4F8
4A8: B5 11 F4 B1 0A           TZ   
                              JC    $4B1
4B5: B2 B0 00 C2 2D           ST    0
                              JM    $22D
4B2: C5 24 11 F4 C2           XC    4
                              TZ   
                              JC    $4C2
4C5: 2A 94 61 24 0A           AD    $461
                              XC    4
42A: 00 C5 36 E4 AF           JM    $536
                              JU    $4AF
4B1: DD 84 54 B0 00           CA    $454
                              ST    0
                              JU    $4DD
4C2: 00 C7 8A E5 B8           JM    $78A        ; Print a CRLF.
5B8: B4 C7 8A C7 95           JM    $78A        ; Print another CRLF.
                              JM    $795
5B4: 00 F5 BC E5 B3           JC    $5BC
                              JU    $5B3        ; Go back for the next register.
;
; $53B - Copies $676 to S4 and sets K to 1 if program register mode is active.
;
53B: AF B4 F2 86 76 ".D.6."   ST    $4F2        ; Put return address in $4F2.
                              CA    $676
5AF: B1 24 84 ED 0B "AM4.#"   XC    4           ; Put contents of $676 in S4.
                              CA    $4ED        ; Get the register mode.
                              CM                ; Negate the mode.
5B1: 00 08 E4 F2 00 " 8.. "   AK                ; Add 1 if mode was non-zero.
                              JU    $4F2        ; K is set now if $4ED was 1.
676: FF FF FD 00 00           DW    $FFFFFD0000
;
; $68D - Command handler for X - Print Register A.
;
68D: B0 0F 80 01 0F           BI   
                              CA    1           ; Fetch A from BI register 1.
                              BI   
6B0: CE 20 87 42 21           XC    0
                              CA    $742
                              XC    1
6CE: 00 C7 00 E5 BC           JM    $700
                              JU    $5BC
;
; $68E - Command handler for Y - Print Register B.
;
68E: B0 0F 80 05 0F           BI   
                              CA    5           ; Fetch B from BI register 5.
                              BI   
                              JU    $6B0
;
; $68F - Command handler for P1 - Read Program Tape.
;
; TODO
;
68F: 00 84 ED E5 0D           CA    $4ED
                              JU    $50D
;
; $452 - Instructions in the high-level language for initializing the
; interpreter and jumping into the user's code to get the ball rolling:
;
;       000     Skipped by "BLS 10" at $40E below
;       189     Select keyboard and printer devices for I/O
;       240     Move the tab position to column 1
;       380     Jump unconditional to program register $000
;
452: 00 18 99 03 80           DW    $0018990380
;
; $690 - Command handler for IIII - Run Application.
;
690: 00 E4 C1 00 00           JU    $4C1
4C1: 80 0F 84 52 22           BI            ; Swap in BI as the active regs.
                              CA    $452    ; Load the initialization word
                              XC    2       ; into BI-2 to get things rolling.
;
; $480 - Interpreter main execution loop.
;
; BI-2 contains the current instruction that is being executed.
; Each instruction is 10 bits in length with 4 instructions per word.
;
; Start by shifting the current instruction word in BI-2 left by 10 bits to
; remove the last instruction that we just executed.
;
480: 0E 84 84 2A 0A           CA    $484    ; Separate the top 10 bits and
                              XT    2       ; bottom 30 bits of BI-2.
40E: 29 B0 00 40 09           ST    0       ; Put the bottom 30 bits in BI-0.
                              BLS   10      ; Shift out the last instruction.
429: C0 11 22 F3 D7           TZ            ; Is the remainder of the word 0?
                              XC    2       ; Put rest of the word into BI-2.
                              JC    $3D7    ; If zero, goto $3D7.
;
; We now have the next instruction to be executed in the top 10 bits of BI-2.
; Inspect the bit pattern to figure out how to handle the instruction:
;
;   00 00xx xxxx    Handled by $4D2
;   00 01xx xxxx    Handled by $465
;   0n nnyy yyyy    Handled by $3C0+0nnn    (variable register instructions)
;   1n nyyy yyyy    Handled by $3C0+1nn0    (program register instructions)
;
4C0: 4E 84 44 3A 0A           CA    $444
                              TG    2
44E: 59 F4 D2 40 00           JC    $4D2    ; Goto $4D2 if 00 00xx xxxx.
                              BLS   1
459: 69 3A F4 65 0A           TG    2
                              JC    $465    ; Goto $465 if 00 01xx xxxx.
;
; $469 - Determine if the instruction is 0n nnyy yyyy or 1n nyyy yyy.
;
469: 7A 80 02 12 0A           CA    2       ; Check the high bit of the
                              TH            ; current instruction.
47A: 07 84 7E D4 83           CA    $47E    ; A = $0003F00000 or $0007F00000
                              AC    $483    ; based on high bit of 0 or 1.
407: A3 28 48 03 20           XT    0       ; Extract nn and yy parts of the
                              BRS   4       ; instruction, with yy in BI-0 and
                              XC    0       ; the nn part in A.
4A3: 30 48 01 94 2C           BRS   2
                              AD    $42C
430: 00 0D 00 00 00           JA            ; Jump to $3C0+nn.
;
; $465 - Handle instructions with the bit pattern 00 01xx xxxx.
;
465: 76 85 69 1A 0A           CA    $569    ; Extract the bottom 5 bits of
                              LA    2       ; the instruction into A.
;
; The next two instructions format a sequence of instructions in A:
;
;   83 80 + xxxxx   CA $380+xxxxx           ; Load variable register xxxxx.
;   20              XC 0                    ; Put it into BI-0.
;   E4 0B           JU $40B                 ; Jump to $40B.
;
476: 30 48 05 92 84           BRS   6
                              AD    $284
                              JU    $430    ; Execute the instruction in A.
569: 07 C0 00 00 00           DW    $07C0000000
284: 83 80 20 E4 0B           DW    $838020E40B
;
; $4D2- Handle instructions with the bit pattern 00 00xx xxxx.
;
;   00 000x xxxx    Handled by $3D0+0xxxxx
;   00 001x 0000    Handled by $3D0+1x0000
;   00 001x yyyy    Handled by $405 if yyyy is non-zero
;
4D2: 5E 48 00 3A 0A           BRS   1       ; Check for 00 000x xxxx or
                              TG    2       ; 00 001x xxxx.
45E: 70 F4 62 84 74           JC    $462
                              CA    $474    ; 00 001x xxxx case.
470: 05 1A F4 62 0A           LA    2       ; Check for 00 001x 0000.
                              JC    $462    ; If yes, use $462 to handle it.
                              JU    $405    ; Otherwise use $405.
462: 78 80 02 48 05           CA    2       ; 00 00nx xxxx case.
                              BRS   6
478: 00 94 7C 0D 00           AD    $47C    ; Dispatch nxxxxx to $3D0+nxxxxx.
                              JA
405: 11 94 09 0B 0A           AD    $409
                              CM   
411: 24 B0 00 27 21           ST    0
                              XC    7
                              XC    1
424: 80 25 C4 28 0A           XC    5
                              JM    $428        ; TODO
                              JU    $480
;
409: 00 40 00 00 00           DW    $0040000000
42C: E3 C0 00 00 00           DW    $E3C0000000
444: 0F FF FF FF FF           DW    $0FFFFFFFFF
474: 03 C0 00 00 00           DW    $03C0000000
47E: 00 03 F0 00 00           DW    $0003F00000
47C: E3 D0 00 00 00           DW    $E3D0000000
483: 00 04 00 00 00           DW    $0004000000
484: 00 3F FF FF FF           DW    $003FFFFFFF
;
; $691 - Command handler for H - Select Hexadecimal Format.
;
691: EA 86 71 B4 E6           CA    $671        ; Select hexadecimal mode.
                              ST    $4E6
6EA: F4 09 B4 ED 0A           CL   
                              ST    $4ED        ; Set the mode in $4ED to 0.
6F4: 00 E5 BC 00 00           JU    $5BC
671: 7E 49 20 00 00           DW    $7E49200000 ; Edit word for hexadecimal.
;
; $576 - Subroutine that waits for the first register number in a range
; to be entered and returns it in $4F4.
;
576: 15 B4 F1 C5 0F           ST    $4F1        ; Save return address in $4F1.
                              JM    $50F        ; Read in a number.
515: 00 B4 F4 E4 F1           ST    $4F4        ; Store the number in $4F4.
                              JU    $4F1        ; Return to the caller.
;
; $50F - Subroutine that waits for a register number to be entered.
;
; The number is returned in A.
;
50F: F1 B4 FE 84 ED           ST    $4FE        ; Save return address in $4FE.
                              CA    $4ED        ; What mode are we in?
5F1: 7E 11 F5 78 12           TZ                ; 0 means hexadecimal mode.
                              JC    $578        ; 1 means program registers.
                              TH                ; -1 means storage registers.
57E: 8A 85 82 D7 86           CA    $582        ; Compute the register limit.
                              AC    $786
58A: 88 B0 03 C5 83           ST    3           ; Set S3 to the register limit.
                              JM    $583        ; Read decimal or octal number.
588: 00 F5 8E E7 0C           JC    $58E
                              JU    $70C        ; Print "ERR" and stop.
578: 8F 86 7C B0 03           CA    $67C        ; Hexadecimal address mode,
                              ST    3           ; change the limit to $FFF.
58F: 00 C5 85 E5 88           JM    $585        ; Read hexadecimal number.
                              JU    $588
58E: 1A 3B F7 0C 0A           TG    3           ; Number over the limit?
                              JC    $70C        ; Print "ERR" and stop.
51A: 00 E4 FE 00 00           JU    $4FE        ; Return to the caller.
582: 9E 82 9D DA 1C           DW    $9E829DDA1C ; CORRUPT!  FIXME!
67C: 00 00 00 0F FF           DW    $0000000FFF
786: 00 00 00 00 40           DW    $0000000040
;
; $583 - Read decimal or octal number.
;
583: 14 21 87 8C 22           XC    1           ; Put return address in S1.
                              CA    $78C
                              XC    2           ; Set S2 to 1.
514: 40 C5 17 60 00           JM    $517        ; Read and parse a digit.
                              DLS   1
540: 55 90 05 25 22           AD    5
                              XC    5
                              XC    2
555: 6D 18 27 F5 6A           LA    0
                              XC    7
                              JC    $56A
56D: 00 E7 0C 00 00           JU    $70C
56A: 00 08 E5 71 00           AK   
                              JU    $571
;
; $585 - Read hexadecimal number.
;
585: 94 21 09 20 0A "UJ9-@"   XC    1           ; Put return address in S1.
                              CL                ; Set S0 to zero.
                              XC    0
594: 40 C5 17 40 03 "..X.3"   JM    $517        ; Read and parse a digit.
                              BLS   4           ; Shift up by 4 bits.
                              JU    $540        ; Add it to the working value.
;
; $517 - Read a digit from the currently selected input device into S5.
;
517: 71 26 09 B0 05           XC    6           ; Put return address in S6.
                              CL                ; Clear S5 and S7 to zero.
                              ST    5
571: 00 27 84 FF 0D           XC    7
                              CA    $4FF        ; Call the char input routine.
                              JA                ; Control returns to $50E.
50E: 39 B0 02 40 1F           ST    2           ; Store the character to S2.
                              BLS   32          ; Shift up by 32 bits.
539: 46 70 00 80 02           OAO               ; Echo the character.
                              CA    2           ; Reload original char from S2.
546: 00 F5 4A E5 0E           JC    $54A
                              JU    $50E        ; Loop if output device busy.
54A: 56 95 4E 95 52           AD    $54E        ; Check if char code >= $41.
                              AD    $552
556: 00 F5 5A E7 0C           JC    $55A
                              JU    $70C        ; Print "ERR" and stop if it is.
;
; The following code does a lookup on $600+char to fetch the parsing rule
; for the character that was just typed.
;
55A: 7D 40 17 95 79           BLS   24
                              AD    $579
57D: 00 0D 00 00 00           JA                ; Table lookup for character.
78D: 1E 87 11 1A 0A           CA    $711        ; AND the rule with $3FF.
                              LA    2
71E: 2D B0 02 48 03           ST    2
                              BRS   4           ; Is bit 3 in the rule set?
72D: 40 25 F0 06 25           XC    5           ; Put the digit into S5.
                              JC    6           ; Success if bit 3 is set.
                              XC    5           ; Revert S5.
740: 53 80 02 48 01           CA    2           ; Get the rule again.
                              BRS   2           ; Is bit 1 set?
753: DE F7 57 48 00           JC    $757        ; If yes, jump to $757.
                              BRS   1           ; Is bit 2 set?
7DE: 00 F7 62 E7 0C           JC    $762        ; If yes, jump to $762.
                              JU    $70C        ; Print "ERR" and stop.
757: 69 27 40 00 10           XC    7
                              BLS   1
                              SK   
769: 00 48 80 E5 71           BRSK  1
                              JU    $571
762: 6E 48 01 F7 6B           BRS   2
                              JC    $76B
76E: 03 48 03 27 0A           BRS   4
                              XC    7
                              JU    $703
76B: F8 27 12 F7 0C           XC    7
                              TH   
                              JC    $70C        ; Print "ERR" and stop.
703: 8F F5 71 40 00           JC    $571
                              BLS   1
78F: 9E 27 F7 1A 0A           XC    7
                              JC    $71A
79E: 08 25 B4 FD 25           XC    5
                              ST    $4FD
                              XC    5
708: 76 22 B4 EF 13           XC    2
                              ST    $4EF
                              RK   
776: 00 80 07 E0 01           CA    7
                              JU    $001
71A: 9E 25 0B 25 0A           XC    5
                              CM   
                              XC    5
                              JU    $79E
;
54E: FF FF FF FF BF           DW    $FFFFFFFFBF
552: 00 00 00 00 41           DW    $0000000041
579: 86 00 22 E7 8D           DW    $860022E78D
;
; $528 - Print the character in the high byte of $4E8 and then move the
; print head to column 4.
;
528: EF 20 84 E8 0A           XC    0           ; Move return addr to S0.
                              CA    $4E8        ; Load the character to print.
5EF: 00 96 73 E6 75           AD    $673        ; Add "move to column 4".
                              JU    $675        ; Print the characters in A.
673: 00 41 00 00 00           DW    $0041000000 ; $41 = move to column 4.
;
; $6D4 - Subroutine that prints a 5-character message.
;
; On entry to this subroutine, S0 is set to the 5-character message and
; A contains the "return address" for the subroutine.
;
; As each character is output, A is shifted left by 8 positions.
; Eventually A will be all-zeroes and the message print stops.
;
6D4: 75 20 70 00 11           XC    0     ; Swap S0 and return addr in A.
                              OAO         ; Output high byte of A and shift.
                              TZ          ; Is A now zero?
675: D4 F0 00 20 0A           JC    0     ; Yes, return from subroutine.
                              XC    0     ; No, swap S0 and A back.
                              JU    $6D4  ; And go handle the next character.
;
; $535 - Subroutine that moves the print head to column 19.
;
535: 35 78 46 F7 A0           OI    $46     ; Output $46 ="move to column 19".
                              JC    $7A0
                              JU    $535
7A0: 00 40 07 13 0D           BLS   8
                              RK   
                              JA            ; Return from the subroutine.
;
; $537 - Subroutine that moves the print head to column 49.
;
537: 37 78 4F F7 A0           OI    $4F     ; Output $4F = "move to column 49".
                              JC    $7A0
                              JU    $537
;
; $78A - Subroutine that prints CRLF to the selected output device(s).
;
78A: 8A 78 40 F7 98           OI    $40     ; Output CR.
                              JC    $798
                              JU    $78A
798: 98 78 3D F7 A0           OI    $3D     ; Output LF.
                              JC    $7A0
                              JU    $798
;
; The entry points at $3D0, $3D1, $3D2, etc are the opcoe handlers
; for the interpreter.  Opcode N is handled by address $3D0+N.
;
; $3D0 - Opcode 000 - Print "EMPTY ERR" and return to the main loop.
;
; Control gets to opcode 000 if the program jumps to an unused address.
;
3D0: F8 84 54 B0 00           CA    $454        ; "EMPTY" message.
                              ST    0
3F8: F9 7E 41 C6 D4           IS    $41
                              JM    $6D4        ; Print "EMPTY".
3F9: 00 E7 0C 00 00           JU    $70C        ; Print "ERR" and exit.
454: 35 24 27 13 18 "EMPTY"   DW    $3524271318
;
; $3D1 - Opcode 001 - XCB - Exchange A and B.
;
3D1: 00 21 25 E3 FF           XC    1           ; Swap A (BI-1) and B (BI-5).
                              XC    5
3FF: 00 B0 01 E4 80           ST    1           ; Store back to A.
                              JU    $480
;
; $3D2 - Opcode 002 - ADD - Add B to A.
;
3D2: FF 80 05 90 01           CA    5           ; Load the value of B.
                              AD    1           ; Add it to A
                              JU    $3FF        ; and then store back to A.
;
; $3D3 - Opcode 003 - JR - Jump Return.
;
3D3: 00 84 FC E2 85           CA    $4FC        ; Get the return address.
285: 86 26 84 FB 22           XC    6           ; Put it into BI-5.
                              CA    $4FB        ; Get the return instruction.
                              XC    2           ; Put it into BI-2.
286: 00 E4 80 00 00           JU    $480        ; Back to interpreter main loop.
;
; $3D4 - Opcode 004 - JPS - Jump if positive.
;
3D4: 00 80 01 E4 5D           CA    1           ; Get the A register's value.
45D: 6F 12 F4 80 0A           TH                ; Is it positive or negative?
                              JC    $480        ; Jump to $480 if negative.
46F: 80 22 40 09 22           XC    2           ; Shift the instruction word
                              BLS   10          ; in BI-2 by 10 bits to skip
                              XC    2           ; the next instruction.
                              JU    $480        ; Back to interpreter main loop.
;
; $3D5 - Opcode 5 - XCV - Exchange A and V00.
;
3D5: 00 83 80 E4 87           CA    $380        ; Get the value of V00.
487: 80 21 B3 80 0A           XC    1           ; Swap it with the A register.
                              ST    $380        ; Store previous A back to V00.
                              JU    $480        ; Back to interpreter main loop.
;
; $3D6 - Opcode 6 - SCO - Single character output with odd parity.
;
3D6: 00 80 01 E4 E5           CA    1
4E5: 00 40 1F E4 6A           BLS   32
46A: 6A 70 00 F4 80           OAO  
                              JC    $480
                              JU    $46A
;
; $3D7 - Opcode 7 - AJ - Automatic Jump.
;
3D7: 00 26 94 61 0D           XC    6           ; Increment the address in BI-6.
                              AD    $461
                              JA                ; Fetch new instruction word.
461: 00 00 01 00 00           DW    $0000010000
;
; $3D8 - Opcode 008 - CLR - Clear A.
;
3D8: 00 09 E3 FF 00           CL   
                              JU    $3FF
;
; $3D9 - Opcode 009 - NGA - Complement A.
;
3D9: 00 21 0B E3 FF           XC    1
                              CM
                              JU    $3FF
;
; $3DA - Opcode 00A - NGB - Complement B.
;
3DA: 00 25 0B E4 6B           XC    5
                              CM   
46B: 00 25 E4 80 00           XC    5
                              JU    $480
;
; $3DB - Opcode 00B - INA - Input from ASCII-coded tape.
;
    ; TODO
;
; $3DC - Opcode 00C - ???
;
    ; TODO
;
; $3DD - Opcode 00D - ???
;
3DD: 00 83 83 E2 27           CA    $383
                              JU    $227
;
; $3DE - Opcode 00E - SCI - Single character input.
;
3DE: DE 5C 00 F4 66           CIOP 
                              JC    $466
                              JU    $3DE
466: 71 12 F4 6D 0A           TH   
                              JC    $46D
471: 00 E3 FF 00 00           JU    $3FF
46D: 72 84 E7 48 03           CA    $4E7
                              BRS   4
472: 7B F7 77 04 0A           JC    $777
                              HH    4
47B: 00 E3 DE 00 00           JU    $3DE
777: 00 02 E3 DE 00           HH    2
                              JU    $3DE
;
; $3DF - Opcode 00F - OPUS - Return to OPUS.
;
3DF: 00 E7 FF 00 00           JU    $7FF
;
; $3E0 - Opcode 010 - SKIP - Skip field from tape.
;
3E0: FA 82 23 B0 00           CA    $223
                              ST    0
3FA: FA 5C 00 F4 08           CIOP 
                              JC    $408
                              JU    $3FA
408: 1B 12 F4 0F 30           TH   
                              JC    $40F
                              TE    0
41B: 00 F4 80 E3 FA           JC    $480
                              JU    $3FA
40F: 00 04 E3 FA 00           HH    4
                              JU    $3FA
;
; $3E1 - Opcode 011 - CALC - Calculate.
;
3E1: 00 C6 65 E2 22           JM    $665
                              JU    $222
;
; $3E2 - Opcode 012 - DCLR - Clear Distribution Registers.
;
3E2: 00 C6 65 E2 35           JM    $665
                              JU    $235
;
; $3E3 - Opcode 013 - DIST - Distribute.
;
3E3: 00 C6 65 E2 07           JM    $665
                              JU    $207
;
; $3E4 - Opcode 014 - DGET - Bring the Distribution Register V07 into A.
;
3E4: FC 21 25 C6 70           XC    1
                              XC    5
                              JM    $670
3FC: 00 E4 80 00 00           JU    $480
;
; $3E5 - Opcode 015 - DPUT - Store A to the Distribution Register V07.
;
3E5: 00 83 87 E2 03           CA    $387
                              JU    $203
;
; $3E6 - Opcode 016 - SCAN - Scan for Non-zero Distribution Register.
;
3E6: 00 87 78 E2 27           CA    $778
                              JU    $227
;
; $3E7 - Opcode 017 - ALFI - Alphanumeric Input.
;
3E7: 00 82 23 E5 E0           CA    $223
5E0: CC 25 86 C5 21           XC    5
                              CA    $6C5
                              XC    1
5CC: CC 5C 00 F5 54           CIOP 
                              JC    $554
                              JU    $5CC
554: E7 35 21 F5 64           TE    5
                              XC    1
                              JC    $564
5E7: C3 40 07 90 01           BLS   8
                              AD    1
5C3: D1 B0 01 12 0A           ST    1
                              TH   
5D1: 00 F5 CC E4 80           JC    $5CC
                              JU    $480
564: C4 40 07 90 01           BLS   8
                              AD    1
5C4: D4 12 F5 CB 21           TH   
                              JC    $5CB
                              XC    1
5D4: 00 E5 58 00 00           JU    $558
5CB: 00 40 07 E5 C4           BLS   8
                              JU    $5C4
;
; $3E8 - Opcode 018 - ALFO - Alphanumeric Output.
;
; Outputs the 5 characters in the A register to the selected output device.
;
; The manual says that the B register is unchanged, but this code will
; actually set B to $1C00000000 if all 5 characters are printed.  Or set it
; to zero if the print ended early due to a [I] terminator.
;
3E8: 00 84 6C E6 E0           CA    $46C        ; Set BI-5 to $1C00000000.
6E0: 77 25 80 01 24           XC    5           ; See $7B7 subroutine below.
                              CA    1           ; Load A register into BI-4.
                              XC    4
677: C4 C7 B7 C7 B7           JM    $7B7        ; Print the 5 characters
                              JM    $7B7        ; that were present in A.
6C4: CD C7 B7 C7 B7           JM    $7B7
                              JM    $7B7
6CD: 00 C7 B7 E4 80           JM    $7B7
                              JU    $480
46C: 1C 00 00 00 00           DW    $1C00000000
;
; $7B7 - Subroutine that prints an alphanumeric character.
;
; On entry, the high byte BI-4 contains the character to print.  On exit,
; it will be shifted up by 8 bits to prepare the next character.
;
; On entry, BI-5 is assumed to be set to $1C00000000, which is the
; character code for the [I] function key.  [I] is used as a terminator
; to stop character output before all 5 characters in Bi-4 are written.
;
7B7: 54 27 24 35 0A           XC    7           ; Put return address in BI-7.
                              XC    4           ; Get the character to print.
                              TE    5           ; Is BI-4 set to [I]?
754: 00 F5 58 E7 5B           JC    $558        ; Bail out if yes.
75B: 5B 70 00 F7 63           OAO               ; Print the char and rotate.
                              JC    $763
                              JU    $75B
763: 00 24 E0 07 00           XC    4           ; Put rotated A back into BI-4.
                              JU    7           ; Return from the subroutine.
558: 00 09 25 E4 80           CL                ; Set B to zero to indicate
                              XC    5           ; that the print ended early.
                              JU    $480
;
; $3E9 - Opcode 019 - SGET - Load Split Distribution Register.
;
3E9: 00 C6 70 E2 F4           JM    $670
                              JU    $2F4
;
; $3EA - Opcode 01A - SPUT - Store Split Distribution Register.
;
3EA: 00 80 01 E4 75           CA    1
475: 89 12 80 05 08           TH   
                              CA    5
                              AK   
489: 2D 40 13 90 01           BLS   20
                              AD    1
42D: 00 B0 01 E3 E5           ST    1
                              JU    $3E5
;
; $3EB - Opcode 01B - CDV - Check-Digit Verification.
;
3EB: 00 86 CA E5 CE           CA    $6CA
5CE: E9 20 09 B0 05           XC    0
                              CL   
                              ST    5
5E9: C7 60 81 B0 04           DLSC  2
                              ST    4
5C7: DE 21 B0 07 12           XC    1
                              ST    7
                              TH   
5DE: 48 F5 62 21 0A           JC    $562
                              XC    1
548: C8 6A 09 C6 ED           DRD   10
                              JM    $6ED
5C8: CA C6 ED C6 ED           JM    $6ED
                              JM    $6ED
5CA: 50 C6 ED C6 ED           JM    $6ED
                              JM    $6ED
550: E4 0B 25 68 00           CM   
                              XC    5
                              DRS   1
5E4: D0 60 00 90 05           DLS   1
                              AD    5
5D0: E8 B0 01 90 04           ST    1
                              AD    4
5E8: D9 0B 27 12 27           CM   
                              XC    7
                              TH   
                              XC    7
5D9: DD F5 DD 0B 0A           JC    $5DD
                              CM   
                              JU    $5DD
562: 00 0B 21 E5 48           CM   
                              XC    1
                              JU    $548
5DD: 00 B0 05 E4 80           ST    5
                              JU    $480
;
; $3EC - Opcode 01C - DUPE - Duplicate data with even parity.
;
3EC: 00 86 F0 E2 74           CA    $6F0
274: D0 92 F9 B0 04           AD    $2F9
                              ST    4
2D0: 00 14 80 04 0D           TP   
                              CA    4
                              JA
6F0: 00 40 00 00 00           DW    $0040000000
2F9: 58 00 D2 88 14           DW    $5800D28814
;
; $3ED - Opcode 01D - DUPO - Duplicate data with odd parity.
;
3ED: 00 09 E2 74 00           CL   
                              JU    $274
;
; $3EE - Opcode 01E - SPEC - Single character output with no parity.
;
3EE: 00 80 01 E3 FD           CA    1
3FD: 00 40 1F E4 A4           BLS   32
4A4: A4 70 C0 F4 80           OA   
                              JC    $480
                              JU    $4A4
;
; $3EF - Opcode 01F - ???
;
3EF: 00 C6 65 E4 34           JM    $665
434: 49 84 3F B0 05           CA    $43F
                              ST    5
449: 14 83 87 B0 00           CA    $387
                              ST    0
414: 2B 68 03 B0 07           DRS   4
                              ST    7
42B: 3C 3D F4 13 0A           TG    5
                              JC    $413
43C: 4B 60 03 0B 0A           DLS   4
                              CM   
44B: D9 90 00 3D 0A           AD    0
                              TG    5
4D9: 67 F4 13 10 08           JC    $413
                              SK   
                              AK   
467: 8B 22 83 83 10           XC    2
                              CA    $383
                              SK   
48B: 19 08 0B 25 0A           AK   
                              CM   
                              XC    5
419: 68 82 D6 B0 01           CA    $2D6
                              ST    1
468: 7D 90 02 21 0A "         AD    2
                              XC    1
                              JU    $47D
;
; $3F0 - Opcode 020 - ???
;
3F0: 00 83 BE E4 C4           CA    $3BE
4C4: 00 40 13 E4 DF           BLS   20
4DF: 80 90 02 0A 22           AD    2
                              XC    2
                              JU    $480
;
; $700 - Print the number in S0 using the edit word formatting rules in S1.
;
; The edit word in S1 defines how the number is to be formatted for output.
;
; If the MSB (bit 39) is set, then the number should have a leading sign.
; The remainder of the edit word is a set of 3-bit edit rules for each
; of the digits or special characters to print.
;
;   000 - Print a space.
;   001 - ???
;   010 - Print a decimal point and then print a decimal digit.
;   011 - Print a space and then print an octal digit.
;   100 - Decimal digit.
;   101 - ???
;   110 - Octal digit.
;   111 - Hexadecimal digit.
;
700: 1B 21 40 00 21           XC    1           ; Shift the edit word in S1
                              BLS   1           ; up by 1 bit.
                              XC    1
71B: 9C B4 FE F7 9B           ST    $4FE        ; Store return address to $4FE.
                              JC    $79B        ; Jump if MSB of edit word is 1.
79C: 30 09 21 11 0A           CL   
                              XC    1
                              TZ   
730: BB F4 FE 40 00           JC    $4FE        ; Return if edit word is now 0.
                              BLS   1           ; Decode next 3-bit edit rule.
7BB: 46 F7 3F 40 00           JC    $73F
                              BLS   1           ; Edit rule is 0XX.
746: D1 F7 CA 40 00           JC    $7CA
                              BLS   1           ; Edit rule is 00X.
7D1: 5D F7 D5 21 0A           JC    $7D5
                              XC    1           ; Edit rule is 000 - space.
75D: 5D 70 00 F7 9C           OAO               ; Print the character in A.
                              JC    $79C
                              JU    $75D
73F: 4B 40 00 F7 47           BLS   1           ; Edit rule is 1XX.
                              JC    $747
74B: D6 40 00 F5 D3           BLS   1           ; Edit rule is 10X.
                              JC    $5D3
7D6: 00 62 00 E5 5E           DLD   1           ; Edit rule is 100 - dec digit.
55E: A9 21 40 10 0A           XC    1
                              BLS   17
5A9: 00 95 2D 0D 00           AD    $52D        ; Load $601+digit*2 into A
                              JA                ; and go print the high byte.
52D: 0A 86 01 E7 5D           DW    $0A8601E75D
5D3: A6 42 05 21 0A           BLD   6           ; Edit rule is 101.
                              XC    1
5A6: 00 40 1F E7 5D           BLS   32
                              JU    $75D
747: D2 40 00 F7 4F           BLS   1           ; Edit rule is 11X.
                              JC    $74F
7D2: 00 42 02 E5 5E           BLD   3           ; Edit rule is 110,
                              JU    $55E        ; which is an octal digit.
74F: 00 42 03 E5 5E           BLD   4           ; Edit rule is 111,
                              JU    $55E        ; which is a hexadecimal digit.
7CA: D7 40 00 F7 52           BLS   1           ; Edit rule is 01X.
                              JC    $752
7D7: D7 78 3B F7 D6           OI    $3B         ; Edit rule is 010.
                              JC    $7D6        ; Print a decimal point
                              JU    $7D7        ; followed by a decimal digit.
752: 52 78 80 F7 D2           OI    $80         ; Edit rule is 011.
                              JC    $7D2        ; Print a space, then print an
                              JU    $752        ; octal digit.
7D5: D5 78 80 F5 5D           OI    $80         ; Edit rule is 001.
                              JC    $55D        ; Output a space.
                              JU    $7D5
55D: A5 21 48 81 18           XC    1
                              BRSK  2
                              LA    0
5A5: 31 21 F7 AC 0A           XC    1
                              JC    $7AC
531: 44 40 02 48 85           BLS   3
                              BRSK  6
                              JU    $544
7AC: BF 10 48 85 0A           SK   
                              BRSK  6
                              JU    $7BF
;
; $79B - Output a number where the edit word has the MSB set.
;
; This is the case when the number should have a leading sign.  Either a
; space or a minus sign is printed and then the rest of the number is
; printed normally.
;
79B: AA 80 00 12 09           CA    0           ; Fetch the number from S0.
                              TH                ; Is it negative (MSB is set)?
                              CL                ; Load a space for +ve sign.
7AA: 00 F7 AE E7 31           JC    $7AE        ; Jump to $7AE if negative.
731: 31 70 00 F6 B9           OAO               ; Output the sign character.
                              JC    $6B9
                              JU    $731
6B9: D7 48 83 20 21           BRSK  4
                              XC    0
                              XC    1
6D7: 00 6A 0B E7 BF           DRD   12
7BF: 00 21 E7 9C 00           XC    1
                              JU    $79C
7AE: 66 40 A5 20 0B           BLSK  38          ; Effectively loads '-' into A.
                              XC    0
                              CM                ; Negate the number to output.
766: 00 20 E7 31 00           XC    0
                              JU    $731        ; Go back to print the '-' sign.
;
; $699 - Print a register number followed by '#'.
;
699: F1 B4 F1 84 ED           ST    $4F1        ; Store return address in $4F1.
                              CA    $4ED        ; Check the register mode.
6F1: 7E 11 F6 79 12           TZ                ; Is it hexadecimal mode?
                              JC    $679        ; Yes, jump to $679.
                              TH                ; Program or storage registers?
67E: 7B 84 F4 F6 F9           CA    $4F4
                              JC    $6F9        ; Jump to $5F9 if storage.
67B: 9C 96 9B 97 09           AD    $69B
                              AD    $709
69C: 00 F6 A2 E7 0C           JC    $6A2
                              JU    $70C        ; Print "ERR" and stop.
679: A6 84 F4 40 1B           CA    $4F4
                              BLS   28
6A6: B8 B0 00 96 B4           ST    0
                              AD    $6B4
6B8: C3 F7 0C 85 BF           JC    $70C        ; Print "ERR" and stop.
                              CA    $5BF
6C3: 00 E6 CC 00 00           JU    $6CC
6CC: A5 B0 01 C7 00           ST    1
                              JM    $700        ; Print the number in S1.
6A5: A5 78 0B F4 F1           OI    $0B         ; Print a '#'.
                              JC    $4F1        ; Return from the subroutine.
                              JU    $6A5
6A2: BC 60 08 B0 00           DLS   9
                              ST    0
6BC: 00 86 C8 E6 CC           CA    $6C8
                              JU    $6CC
6F9: A4 96 FE 97 86           AD    $6FE
                              AD    $786
6A4: 00 E6 9C 00 00           JU    $69C
;
5BF: 7F C0 00 00 00           DW    $7FC0000000
69B: FF FF FF FC 80           DW    $FFFFFFFC80
6B4: 00 10 00 00 00           DW    $0010000000
6C8: C9 00 00 00 00           DW    $C900000000
5FE: 10 97 02 11 0A           DW    $109702110A
709: 00 00 00 00 80           DW    $0000000080
786: 00 00 00 00 40           DW    $0000000040
;
; $795 - Check if the address in $4F4 is greater than or equal to $3BF.
; If it is, then return with K set to 1.  Otherwise increment the address
; in $4F4 and return with K set to 0.
;
795: F4 20 84 E9 21           XC    0           ; Put return address into S0.
                              CA    $4E9
                              XC    1
7F4: 23 84 F4 39 0A           CA    $4F4        ; Compare value of $4F4
                              TG    1           ; with S1 = $3BF.
723: B0 F0 00 10 08           JC    0
                              SK                ; Increment $4F4.
                              AK
7B0: 00 B4 F4 E0 00           ST    $4F4
                              JU    0           ; Return from the subroutine.
4E9: 00 00 00 03 BF           DW    $00000003BF
;
; $72E - Reads the word at the memory address in $4F4 into $4FD.
;
72E: 45 20 86 BB 22           XC    0           ; Put return address into S0.
                              CA    $6BB
                              XC    2           ; Copy $6BB instruction into S2.
745: A2 84 F4 40 07           CA    $4F4        ; Get the address to read and
                              BLS   8           ; add it to the instruction
7A2: B5 97 A6 B0 01           AD    $7A6        ; at $7A6.
                              ST    1           ; Put the new instruction in S1
7B5: 00 E0 01 00 00           JU    1           ; and then execute it.
6BB: 00 B4 FD E0 00           ST    $4FD
                              JU    0
7A6: 02 0F 80 00 0F           BI
                              CA    $000        ; Replaced with address to read.
                              BI
                              JU    2
;
; $6A1 - Prints the value in $4FD.
;
6A1: A9 B4 F1 84 FD           ST    $4F1        ; Put return address in $4F1.
                              CA    $4FD        ; Get the value to print.
6A9: 6B 20 84 E6 0A           XC    0           ; Put it into S0.
                              CA    $4E6        ; Get the number format rules.
66B: FB B0 01 48 01           ST    1           ; Put them into S1.
                              BRS   2           ; Is the edit word octal?
6FB: 00 F7 A8 E7 A9           JC    $7A8        ; Jump to $7A8 if it is.
7A9: 00 C7 00 E4 F1           JM    $700        ; Print the number in S0.
                              JU    $4F1        ; Return from subroutine.
;
; Special case for printing octal.  Deal with the high bit by printing
; either a space or a '1'.  Then print the rest of the word.
;
7A8: BC 20 40 00 20           XC    0           ; Shift the number up by 1 bit.
                              BLS   1
                              XC    0
7BC: CE 48 80 48 06           BRSK  1           ; Turn the bit into SP or '1'.
                              BRS   7
7CE: CE 70 00 F7 A9           OAO               ; Print the character.
                              JC    $7A9        ; Jump to $7A9 when complete.
                              JU    $7CE
